/*
 * FlameWerks Remote Burner Control System - SINGLE RELAY TEST VERSION
 * ESP8266 Thing Dev Board - Auburn I-31-2 Igniter Compatible
 * 
 * WARNING: TESTING CONFIGURATION - SINGLE RELAY ONLY
 * This version uses only 1 relay for PILOT VALVE control
 * Main valve functionality is DISABLED for testing
 * 
 * Current Hardware Configuration (TESTING):
 * GPIO 2  -> Pilot Valve Relay (via PC817 optocoupler) [ACTIVE]
 * GPIO 4  -> Beefcake Relay -> 12V Glow Plug Control [ACTIVE]
 * GPIO 5  -> Flame Rod Bias (PWM for rectification) [ACTIVE]
 * A0      -> Flame Rod Input (via 1MŒ© resistor - flame rectification) [ACTIVE]
 * 
 * IMPORTANT NOTE ON FLAME ROD CONNECTION FOR ACCURATE SENSING:
 * - Connect GPIO5 directly to the flame rod (the end not in the flame).
 * - Connect the flame rod to A0 via 1MŒ© resistor.
 * - Remove any low-value resistor (e.g., 220 ohm) to ground, as it shunts the signal.
 * - The ground path completes through the flame to a grounded burner/chassis.
 * - For lighter testing: Connect ESP GND to lighter's metal body to close the circuit.
 * 
 *  STANDARD PRODUCTION CONFIGURATION (when you get 2nd relay):
 *  GPIO 2  -> Pilot Valve Relay (via PC817 optocoupler)
 *  GPIO 4  -> Main Valve Relay (via PC817 optocoupler) 
 *  GPIO 5  -> Igniter Control (Auburn I-31-2)
 *  A0      -> Flame Sensor (Auburn I-31-2 + 1MŒ© resistor)
 *  
 *  Standard Operation:
 *  1. PILOT_IGNITING: Open pilot valve + igniter spark
 *  2. PILOT_ESTABLISHED: Pilot flame detected, stabilize 2 seconds
 *  3. MAIN_ON: Open main valve for full operation
 *  
 *  Testing Operation (Current):
 *  1. PILOT_IGNITING: Open pilot valve + glow plug on
 *  2. PILOT_ON: Pilot flame detected, stay in pilot mode, glow plug off
 *  3. Main valve commands are logged but not executed
 
 * 
 * Safety Features:
 * - 5-second ignition timeout with automatic shutoff
 * - Flame loss detection with immediate emergency closure
 * - 3-attempt retry logic with 3-second cooldown
 * - Fault state requiring manual reset
 * - Electrical isolation via PC817 optocouplers
 */

#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <ESP8266mDNS.h>
#include <WiFiClient.h>

// --- Pin Definitions (ESP8266 Thing Dev Board) ---
#define PILOT_RELAY_PIN  2    // GPIO2 -> PC817 -> Pilot Valve Relay [ACTIVE]
#define MAIN_RELAY_PIN   4    // GPIO4 -> Relay/MOSFET -> 12V Glow Plug Control [ACTIVE]
#define FLAME_ROD_OUT_PIN 5   // GPIO5 -> Flame Rod AC Output [ACTIVE]
#define IGNITER_PIN      5    // GPIO5 -> Igniter/Flame Rod Output [ACTIVE] (alias)
#define FLAME_SENSE_PIN  A0   // A0 -> Flame Rod Input via 1MŒ© (rectification) [ACTIVE]

// --- Configuration ---
const char* ssid = "Alesong Danebo";        // Updated WiFi name
const char* password = "Alesong123#";           // Updated WiFi password
const char* hostname = "flamewerks-burner";

// --- Burner State Machine (MODIFIED FOR SINGLE RELAY TESTING) ---
enum BurnerState {
  OFF,                // All systems off, safe state
  PILOT_IGNITING,     // Opening pilot valve + igniter spark
  PILOT_ON,           // Pilot flame confirmed and stable (TESTING MODE)
  // PILOT_ESTABLISHED,  // (Standard mode - disabled for testing)
  // MAIN_ON,           // (Standard mode - disabled for testing)
  FLAMEOUT,          // Flame lost, cooldown period
  FAULT              // System fault, manual reset required
};

// --- Burner Control Structure ---
struct BurnerController {
  int id;
  BurnerState state;
  unsigned long stateStartTime;
  int retryAttempt;
  bool flameDetected;
  bool igniterActive;
  bool pilotValveOpen;
  bool mainValveOpen;
  int lastFlameReading;
};

// Initialize single burner (expandable to multi-burner array)
BurnerController burner = {1, OFF, 0, 0, false, false, false, false, 0};

// --- Enhanced Safety Parameters ---
const unsigned long PILOT_IGNITION_TIME_MS = 5000;   // 5 seconds for pilot ignition
const unsigned long PILOT_STABILIZE_TIME_MS = 2000;  // 2 seconds to stabilize pilot
const unsigned long FLAME_CHECK_INTERVAL_MS = 100;   // Check flame every 100ms
const unsigned long FLAME_LOSS_TIMEOUT_MS = 500;     // 500ms to detect flame loss
const unsigned long COOLDOWN_PERIOD_MS = 3000;       // 3 second cooldown between attempts
const int MAX_IGNITION_ATTEMPTS = 3;                 // Maximum retry attempts
const int FLAME_DETECTION_THRESHOLD = 55;            // Lowered from 50 for better flame sensitivity
const int FLAME_HYSTERESIS = 3;                      // Reduced hysteresis for faster response

// --- Enhanced Signal Filtering Parameters ---
const int FILTER_SAMPLES = 16;                       // Increased samples for better averaging
const int STABILITY_REQUIRED = 5;                    // More consecutive readings required for flame on
const int STABILITY_REQUIRED_OFF = 3;                // Fewer readings required to turn off (faster safety)
const int MAX_NOISE_TOLERANCE = 25;                  // Increased tolerance for noisy environments
const int OUTLIER_REJECTION_SAMPLES = 8;             // Number of rapid samples for outlier rejection

// --- Web Server ---
ESP8266WebServer server(80);

// --- Hardware Control Functions ---
void setPilotValve(bool state) {
  digitalWrite(PILOT_RELAY_PIN, state ? HIGH : LOW);
  burner.pilotValveOpen = state;
  Serial.print("Pilot valve: ");
  Serial.println(state ? "OPEN" : "CLOSED");
}

void setMainValve(bool state) {
  // WARNING: TESTING MODE: Main valve relay not connected
  Serial.print("Main valve (SIMULATED): ");
  Serial.println(state ? "OPEN" : "CLOSED");
  Serial.println("   --> No hardware connected - command logged only");
  
  burner.mainValveOpen = state;  // Track state for web UI
  
  // digitalWrite(MAIN_RELAY_PIN, state ? HIGH : LOW);  // Disabled - no hardware
}

// Glow plug control function (using pin 4)
void setGlowPlug(bool state) {
  digitalWrite(MAIN_RELAY_PIN, state ? HIGH : LOW);  // Pin 4 controls glow plug circuit
  burner.igniterActive = state;
  Serial.print("Glow plug (Pin 4): ");
  Serial.println(state ? "ON (3.3V signal -> 12V glow plug)" : "OFF (0V signal -> glow plug off)");
  Serial.println("   NOTE: Pin 4 outputs 3.3V to control relay/MOSFET that switches 12V to glow plug");
}

void emergencyShutdown() {
  setPilotValve(false);
  setMainValve(false);
  setGlowPlug(false);
  burner.state = OFF;
  burner.retryAttempt = 0;
  Serial.println("*** EMERGENCY SHUTDOWN - ALL SYSTEMS OFF ***");
}

bool readFlameStatus() {
  // Enhanced multi-sample averaging with outlier rejection
  static int sampleBuffer[FILTER_SAMPLES];
  static int sampleIndex = 0;
  static bool bufferFilled = false;
  static int stableFlameCount = 0;
  static int stableNoFlameCount = 0;
  static bool lastStableFlame = false;
  static unsigned long lastReadTime = 0;
  
  // Rate limiting - don't read too frequently to reduce noise
  if (millis() - lastReadTime < 50) {
    return lastStableFlame;
  }
  lastReadTime = millis();
  
  // Take multiple rapid readings and filter out outliers
  int readings[OUTLIER_REJECTION_SAMPLES];
  for (int i = 0; i < OUTLIER_REJECTION_SAMPLES; i++) {
    readings[i] = analogRead(FLAME_SENSE_PIN);
    delayMicroseconds(200); // Small delay between readings
  }
  
  // Sort readings to find median (removes outliers)
  for (int i = 0; i < OUTLIER_REJECTION_SAMPLES - 1; i++) {
    for (int j = i + 1; j < OUTLIER_REJECTION_SAMPLES; j++) {
      if (readings[i] > readings[j]) {
        int temp = readings[i];
        readings[i] = readings[j];
        readings[j] = temp;
      }
    }
  }
  
  // Use median of middle readings (removes highest and lowest outliers)
  int startIdx = OUTLIER_REJECTION_SAMPLES / 4;
  int endIdx = OUTLIER_REJECTION_SAMPLES * 3 / 4;
  int total = 0;
  for (int i = startIdx; i < endIdx; i++) {
    total += readings[i];
  }
  int filteredReading = total / (endIdx - startIdx);
  
  // Fill circular buffer with filtered reading
  sampleBuffer[sampleIndex] = filteredReading;
  sampleIndex = (sampleIndex + 1) % FILTER_SAMPLES;
  if (!bufferFilled && sampleIndex == 0) {
    bufferFilled = true;
  }
  
  // Calculate moving average
  total = 0;
  int samplesUsed = bufferFilled ? FILTER_SAMPLES : sampleIndex;
  for (int i = 0; i < samplesUsed; i++) {
    total += sampleBuffer[i];
  }
  int movingAverage = total / samplesUsed;
  
  // Calculate noise level for stability assessment
  int maxSample = 0, minSample = 1024;
  for (int i = 0; i < samplesUsed; i++) {
    if (sampleBuffer[i] > maxSample) maxSample = sampleBuffer[i];
    if (sampleBuffer[i] < minSample) minSample = sampleBuffer[i];
  }
  int noiseLevel = maxSample - minSample;
  
  // Store for debugging
  burner.lastFlameReading = movingAverage;
  
  // Enhanced floating pin detection
  static int consecutiveMaxReadings = 0;
  static int consecutiveMinReadings = 0;
  static bool hasWarnedFloating = false;
  
  if (movingAverage >= 1020) {
    consecutiveMaxReadings++;
    consecutiveMinReadings = 0;
    if (consecutiveMaxReadings >= 5 && !hasWarnedFloating) {
      Serial.println("*** WARNING: A0 PIN FLOATING! ***");
      Serial.println("FIX: Connect 1MŒ© resistor from A0 to GND");
      hasWarnedFloating = true;
    }
  } else if (movingAverage <= 10) {
    consecutiveMinReadings++;
    consecutiveMaxReadings = 0;
    if (hasWarnedFloating && consecutiveMinReadings >= 3) {
      Serial.println("*** A0 PIN STABILIZED ***");
      hasWarnedFloating = false;
    }
  } else {
    consecutiveMaxReadings = 0;
    consecutiveMinReadings = 0;
  }
  
  // Adaptive threshold based on noise level
  int adaptiveThreshold = FLAME_DETECTION_THRESHOLD;
  if (noiseLevel > 20) {
    adaptiveThreshold += noiseLevel / 3; // Increase threshold if noisy
  }
  
  // Determine potential flame state with hysteresis
  bool potentialFlame;
  if (movingAverage >= 1020) {
    potentialFlame = false; // Ignore floating readings
  } else {
    if (lastStableFlame) {
      // Use hysteresis when turning off (easier to turn off)
      potentialFlame = movingAverage > (adaptiveThreshold - FLAME_HYSTERESIS);
    } else {
      // Use hysteresis when turning on (harder to turn on)
      potentialFlame = movingAverage > (adaptiveThreshold + FLAME_HYSTERESIS);
    }
  }
  
  // Require stability before changing state
  bool isStable = (noiseLevel <= MAX_NOISE_TOLERANCE) && bufferFilled;
  
  if (isStable && potentialFlame) {
    stableFlameCount++;
    stableNoFlameCount = 0;
  } else if (isStable && !potentialFlame) {
    stableNoFlameCount++;
    stableFlameCount = 0;
  } else {
    // Not stable - reduce counters gradually to prevent false triggers
    if (noiseLevel > MAX_NOISE_TOLERANCE) {
      stableFlameCount = max(0, stableFlameCount - 1);
      stableNoFlameCount = max(0, stableNoFlameCount - 1);
    }
  }
  
  // Change state only after consecutive stable readings
  bool newFlameState = lastStableFlame;
  
  if (stableFlameCount >= STABILITY_REQUIRED) {
    newFlameState = true;
    stableFlameCount = STABILITY_REQUIRED; // Prevent overflow
  } else if (stableNoFlameCount >= STABILITY_REQUIRED_OFF) {
    newFlameState = false;
    stableNoFlameCount = STABILITY_REQUIRED_OFF;
  }
  
  // Report state changes
  if (newFlameState != lastStableFlame) {
    if (newFlameState) {
      Serial.print("üî• STABLE FLAME DETECTED! Avg: ");
      Serial.print(movingAverage);
      Serial.print(" (Filtered: ");
      Serial.print(filteredReading);
      Serial.print(", Noise: ");
      Serial.print(noiseLevel);
      Serial.print(", Threshold: ");
      Serial.print(adaptiveThreshold);
      Serial.println(") üî•");
    } else {
      Serial.print("‚ùÑÔ∏è STABLE FLAME LOST - Avg: ");
      Serial.print(movingAverage);
      Serial.print(" (Noise: ");
      Serial.print(noiseLevel);
      Serial.print(", Below: ");
      Serial.print(adaptiveThreshold);
      Serial.println(") ‚ùÑÔ∏è");
    }
    lastStableFlame = newFlameState;
  }
  
  // Enhanced debug output every 5 seconds
  static unsigned long lastDebugOutput = 0;
  if (millis() - lastDebugOutput > 5000) {
    Serial.print("Flame - Raw: ");
    Serial.print(analogRead(FLAME_SENSE_PIN));
    Serial.print(" | Filt: ");
    Serial.print(filteredReading);
    Serial.print(" | Avg: ");
    Serial.print(movingAverage);
    Serial.print(" | Noise: ");
    Serial.print(noiseLevel);
    Serial.print(" | Thresh: ");
    Serial.print(adaptiveThreshold);
    Serial.print(" | Flame: ");
    Serial.print(newFlameState ? "üî• YES" : "‚ùÑÔ∏è NO");
    Serial.print(" | Stable: ");
    Serial.print(isStable ? "YES" : "NO");
    if (movingAverage >= 1020) {
      Serial.print(" [FLOATING!]");
    }
    Serial.println();
    lastDebugOutput = millis();
  }
  
  return newFlameState;
}

// Reset flame filter to clear any corrupted static variables
void resetFlameFilter() {
  Serial.println("=== RESETTING FLAME FILTER ===");
  Serial.println("The best way to reset corrupted static variables is to restart the ESP8266");
  Serial.println("");
  Serial.println("RECOMMENDED SOLUTIONS:");
  Serial.println("1. Press the RESET button on your ESP8266");
  Serial.println("2. Disconnect and reconnect power");
  Serial.println("3. Re-upload this firmware");
  Serial.println("");
  Serial.println("This will completely clear all static variables and give you a fresh start.");
  Serial.println("After restart, run 'stability_test' for clean results.");
}

// --- Enhanced State Machine Logic (SINGLE RELAY VERSION) ---
void updateBurnerStateMachine() {
  unsigned long currentTime = millis();
  
  // Faster state machine updates for better flame responsiveness
  static unsigned long lastStateMachineUpdate = 0;
  if (currentTime - lastStateMachineUpdate < 250) {  // Changed from 1000ms to 250ms
    return; // Update state machine every 250ms for faster flame response
  }
  lastStateMachineUpdate = currentTime;
  
  // Read flame status more frequently
  burner.flameDetected = readFlameStatus();
  
  switch (burner.state) {
    case OFF:
      // Safe state - all systems off (only set once per state change)
      static BurnerState lastState = FAULT; // Initialize to different state
      if (lastState != OFF) {
        setPilotValve(false);
        setMainValve(false);
        Serial.println("System in OFF state - Type 'help' for commands");
        lastState = OFF;
      }
      break;
      
    case PILOT_IGNITING:
      lastState = PILOT_IGNITING;
      // Phase 1: Open pilot valve (flame rod is passive receiver only)
      setPilotValve(true);
      setMainValve(false);
      setGlowPlug(true); // Activate glow plug for ignition
      
      if (burner.flameDetected) {
        // Pilot flame established! (Testing mode - stay in pilot)
        burner.state = PILOT_ON;  // Modified for testing
        burner.stateStartTime = currentTime;
        burner.retryAttempt = 0;  // Reset retry counter
        setGlowPlug(false); // Turn off glow plug after flame detected
        Serial.println("STATE: Pilot flame detected via flame rod -> PILOT_ON (TESTING MODE)");
        Serial.println("   --> In production mode, this would proceed to main valve");
      } 
      else if (currentTime - burner.stateStartTime > PILOT_IGNITION_TIME_MS) {
        // Ignition timeout
        setPilotValve(false);
        setGlowPlug(false);
        
        if (burner.retryAttempt < MAX_IGNITION_ATTEMPTS) {
          burner.retryAttempt++;
          burner.state = FLAMEOUT;
          burner.stateStartTime = currentTime;
          Serial.print("STATE: Pilot ignition failed, attempt ");
          Serial.print(burner.retryAttempt);
          Serial.print("/");
          Serial.println(MAX_IGNITION_ATTEMPTS);
        } else {
          burner.state = FAULT;
          burner.stateStartTime = currentTime;
          Serial.println("STATE: Maximum ignition attempts exceeded -> FAULT");
        }
      }
      break;
      
    case PILOT_ON:
      lastState = PILOT_ON;
      // Testing mode: Pilot running, main valve simulated
      setPilotValve(true);
      setMainValve(true);  // Simulated only
      
      if (!burner.flameDetected) {
        // Pilot flame lost!
        emergencyShutdown();
        burner.state = FLAMEOUT;
        burner.stateStartTime = currentTime;
        Serial.println("STATE: Pilot flame lost (flame rod) -> EMERGENCY FLAMEOUT");
      }
      break;
      
    case FLAMEOUT:
      lastState = FLAMEOUT;
      // Cooldown period before retry
      setPilotValve(false);
      setMainValve(false);
      
      if (currentTime - burner.stateStartTime > COOLDOWN_PERIOD_MS) {
        if (burner.retryAttempt < MAX_IGNITION_ATTEMPTS) {
          // Attempt restart
          burner.state = PILOT_IGNITING;
          burner.stateStartTime = currentTime;
          Serial.println("STATE: Cooldown complete, retrying ignition -> PILOT_IGNITING");
        } else {
          burner.state = FAULT;
          Serial.println("STATE: Maximum retries exceeded -> FAULT");
        }
      }
      break;
      
    case FAULT:
      lastState = FAULT;
      // System fault - requires manual reset
      setPilotValve(false);
      setMainValve(false);
      
      // Fault state can only be cleared by manual reset command
      break;
  }
}

// --- Web Server Handlers ---
void handleRoot() {
  // Serve the web UI
  server.sendHeader("Content-Type", "text/html");
  server.send(200, "text/html", getWebUI());
}

void handleStatus() {
  // Return enhanced status as JSON
  String json = "[{";
  json += "\"id\":1,";
  json += "\"state\":\"";
  
  switch (burner.state) {
    case OFF: json += "off"; break;
    case PILOT_IGNITING: json += "igniting"; break;
    case PILOT_ON: json += "pilot-running"; break;  // Modified for testing
    case FLAMEOUT: json += "flameout"; break;
    case FAULT: json += "fault"; break;
  }
  
  json += "\",\"flame\":";
  json += burner.flameDetected ? "true" : "false";
  json += ",\"attempts\":";
  json += String(burner.retryAttempt);
  json += ",\"maxAttempts\":";
  json += String(MAX_IGNITION_ATTEMPTS);
  json += ",\"flameSensorValue\":";
  json += String(burner.lastFlameReading);
  json += ",\"igniterActive\":";
  json += burner.igniterActive ? "true" : "false";
  json += ",\"pilotOpen\":";
  json += burner.pilotValveOpen ? "true" : "false";
  json += ",\"mainOpen\":";
  json += burner.mainValveOpen ? "true" : "false";
  json += "}]";
  
  server.send(200, "application/json", json);
}

void handleControl() {
  String response = "";
  
  if (server.hasArg("cmd")) {
    String cmd = server.arg("cmd");
    
    if (cmd == "ignite" || cmd == "on") {
      if (burner.state == OFF || burner.state == FAULT) {
        burner.state = PILOT_IGNITING;
        burner.stateStartTime = millis();
        burner.retryAttempt = 0;
        response = "Ignition sequence initiated - Pilot valve opening";
        Serial.println("WEB COMMAND: Starting ignition sequence");
      } else {
        response = "Burner already active or in ignition process";
      }
    }
    else if (cmd == "stop" || cmd == "off") {
      emergencyShutdown();
      response = "Emergency shutdown executed - All systems OFF";
      Serial.println("WEB COMMAND: Emergency shutdown");
    }
    else if (cmd == "reset") {
      if (burner.state == FAULT) {
        burner.state = OFF;
        burner.retryAttempt = 0;
        response = "System reset from FAULT to OFF state";
        Serial.println("WEB COMMAND: Fault reset to OFF");
      } else {
        response = "Reset command only available in FAULT state";
      }
    }
    else {
      response = "Unknown command: " + cmd + " (use: ignite, stop, reset)";
    }
  } else {
    response = "Missing cmd parameter";
  }
  
  server.send(200, "text/plain", response);
}

void handleNotFound() {
  server.send(404, "text/plain", "File not found");
}

// --- Serial Command Interface ---
void handleSerialCommands() {
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('\n');
    cmd.trim();
    cmd.toLowerCase();
    
    if (cmd == "i" || cmd == "ignite") {
      if (burner.state == OFF || burner.state == FAULT) {
        burner.state = PILOT_IGNITING;
        burner.stateStartTime = millis();
        burner.retryAttempt = 0;
        Serial.println("SERIAL: Ignition sequence started");
      } else {
        Serial.println("SERIAL: Burner already active");
      }
    }
    else if (cmd == "s" || cmd == "stop" || cmd == "off") {
      emergencyShutdown();
      Serial.println("SERIAL: Emergency shutdown executed");
    }
    else if (cmd == "r" || cmd == "reset") {
      burner.state = OFF;
      burner.retryAttempt = 0;
      Serial.println("SERIAL: System reset to OFF");
    }
    else if (cmd == "status" || cmd == "st") {
      Serial.println("=== FLAMEWERKS BURNER STATUS ===");
      
      // Add WiFi status first
      Serial.print("WiFi Status: ");
      if (WiFi.status() == WL_CONNECTED) {
        Serial.print("CONNECTED to ");
        Serial.println(WiFi.SSID());
        Serial.print("IP Address: ");
        Serial.println(WiFi.localIP());
        Serial.print("Web UI: http://");
        Serial.println(WiFi.localIP());
      } else {
        Serial.println("DISCONNECTED");
        Serial.print("Trying to connect to: ");
        Serial.println(ssid);
      }
      Serial.println("--------------------------------");
      
      Serial.print("State: ");
      switch (burner.state) {
        case OFF: Serial.println("OFF"); break;
        case PILOT_IGNITING: Serial.println("PILOT_IGNITING"); break;
        case PILOT_ON: Serial.println("PILOT_ON (TESTING MODE)"); break;
        case FLAMEOUT: Serial.println("FLAMEOUT"); break;
        case FAULT: Serial.println("FAULT"); break;
      }
      Serial.print("Flame detected: ");
      Serial.println(burner.flameDetected ? "YES" : "NO");
      Serial.print("Flame sensor ADC: ");
      Serial.println(burner.lastFlameReading);
      Serial.print("Ignition attempts: ");
      Serial.print(burner.retryAttempt);
      Serial.print("/");
      Serial.println(MAX_IGNITION_ATTEMPTS);
      Serial.print("Hardware status - Flame Rod: ");
      Serial.print(digitalRead(FLAME_ROD_OUT_PIN) ? "ACTIVE" : "OFF");
      Serial.print(", Pilot: ");
      Serial.print(burner.pilotValveOpen ? "OPEN" : "CLOSED");
      Serial.print(", Main: ");
      Serial.println(burner.mainValveOpen ? "OPEN" : "CLOSED");
      Serial.println("==============================");
    }
    else if (cmd == "reset_filter") {
      resetFlameFilter();
    }
    else if (cmd == "force_reset_filter") {
      Serial.println("=== FORCING FILTER RESET ===");
      Serial.println("This will completely clear all static variables in the flame filter");
      
      // Set the force reset flag that will be picked up by readFlameStatus()
      // We need to access the static variable, so we'll restart the ESP instead
      Serial.println("SOLUTION: Restart the ESP8266 to completely clear all static variables");
      Serial.println("1. Press the reset button on your ESP8266, OR");
      Serial.println("2. Disconnect and reconnect power, OR");
      Serial.println("3. Re-upload this firmware");
      Serial.println("This will guarantee all filter buffers are completely cleared.");
    }
    else if (cmd == "filter_check") {
      Serial.println("=== SIMPLE FILTER CHECK ===");
      Serial.println("Taking 5 raw ADC readings...");
      
      int rawReadings[5];
      int rawTotal = 0;
      for (int i = 0; i < 5; i++) {
        rawReadings[i] = analogRead(FLAME_SENSE_PIN);
        rawTotal += rawReadings[i];
        Serial.print("Raw reading "); Serial.print(i+1); 
        Serial.print(": "); Serial.println(rawReadings[i]);
        delay(200);
      }
      int rawAvg = rawTotal / 5;
      
      Serial.print("Raw average: "); Serial.println(rawAvg);
      Serial.println("");
      Serial.println("DIAGNOSIS:");
      if (rawAvg < 10) {
        Serial.println("‚úÖ Good baseline - low readings as expected with no flame");
      } else if (rawAvg > 100) {
        Serial.println("‚ö†Ô∏è  High readings - check for flame source or interference");
      } else {
        Serial.println("‚ÑπÔ∏è  Moderate readings - acceptable range");
      }
      Serial.println("");
      Serial.println("If you're getting false flame detections with low raw readings,");
      Serial.println("the filter buffers are corrupted. SOLUTION: Restart ESP8266");
      Serial.println("==========================");
    }
    else if (cmd == "adc_diagnostic") {
      performADCDiagnostic();
    }
    else if (cmd == "stability_test") {
      performStabilityTest();
    }
    else if (cmd == "help" || cmd == "h") {
      Serial.println("=== FLAMEWERKS SERIAL COMMANDS ===");
      Serial.println("i/ignite     - Start ignition sequence");
      Serial.println("s/stop       - Emergency shutdown");
      Serial.println("r/reset      - Reset system to OFF");
      Serial.println("status/st    - Show detailed status");
      Serial.println("test         - Basic flame sensor test");
      Serial.println("flame_test   - Detailed flame sensor analysis");
      Serial.println("flame_test_live - Live flame monitoring with filtering");
      Serial.println("noise_test   - Analyze signal noise for 30 seconds");
      Serial.println("flame_cal    - Calibrate flame sensor");
      Serial.println("flame_continuous - Continuous flame monitoring");
      Serial.println("test_no_flame    - Test baseline with no flame");
      Serial.println("a0_test          - Enhanced A0 pin stability test (20 readings)");
      Serial.println("wiring_test      - Diagnose A0 pin wiring issues");
      Serial.println("flame_diagnostic - COMPLETE flame system diagnostic");
      Serial.println("filter_check     - Check for filter corruption (RECOMMENDED)");
      Serial.println("adc_diagnostic   - NEW: Diagnose ADC reading problems");
      Serial.println("reset_filter     - Reset flame sensor filter buffers");
      Serial.println("force_reset_filter - FORCE complete filter reset (restart ESP)");
      Serial.println("stability_test   - NEW: Test improved filtering algorithm");
      Serial.println("glow_on      - Turn glow plug ON (pin 4)");
      Serial.println("glow_off     - Turn glow plug OFF (pin 4)");
      Serial.println("glow_test    - Test glow plug control sequence");
      Serial.println("pin_test     - Test all GPIO pin outputs");
      Serial.println("help/h       - Show this help");
      Serial.println("===================================");
    }
    else if (cmd == "test") {
      Serial.println("=== FLAME ROD TEST ===");
      Serial.println("Testing flame rod rectification circuit...");
      Serial.println("NOTE: Flame rod is passive receiver - bring flame close to test");
      for (int i = 0; i < 10; i++) {
        int reading = analogRead(FLAME_SENSE_PIN);
        Serial.print("Reading ");
        Serial.print(i + 1);
        Serial.print(": ");
        Serial.print(reading);
        Serial.print(" (Threshold: ");
        Serial.print(FLAME_DETECTION_THRESHOLD);
        Serial.print(", Detected: ");
        Serial.print(reading > FLAME_DETECTION_THRESHOLD ? "YES" : "NO");
        Serial.println(")");
        delay(500);
      }
      Serial.println("========================");
    }
    else if (cmd == "flame_test") {
      testFlameRodDetailed();
    }
    else if (cmd == "test_no_flame") {
      Serial.println("=== NO FLAME BASELINE TEST ===");
      Serial.println("Testing sensor baseline with no flame present");
      Serial.println("Make sure no flame or heat source is near the flame rod");
      Serial.println();
      
      Serial.println("Taking 10 readings with NO flame present...");
      int total = 0;
      for (int i = 0; i < 10; i++) {
        int reading = analogRead(FLAME_SENSE_PIN);
        total += reading;
        bool detected = reading > FLAME_DETECTION_THRESHOLD;
        
        Serial.print("Reading ");
        Serial.print(i + 1);
        Serial.print(": ADC=");
        Serial.print(reading);
        Serial.print(", Detected=");
        Serial.print(detected ? "YES" : "NO");
        if (reading >= 1020) {
          Serial.print(" (FLOATING!)");
        }
        Serial.println();
        delay(500);
      }
      
      int average = total / 10;
      Serial.print("RESULT: Average ADC = ");
      Serial.print(average);
      Serial.print(", Should be LOW (< 30) for good baseline");
      Serial.println();
      
      if (average < 30) {
        Serial.println("GOOD: Low baseline - flame sensor circuit working properly");
      } else if (average >= 1020) {
        Serial.println("PROBLEM: A0 pin floating - check wiring and 1MŒ© resistor");
      } else {
        Serial.println("WARNING: High baseline - check for interference or heat sources");
      }
      Serial.println("======================");
    }
    else if (cmd == "flame_test_live") {
      Serial.println("=== LIVE FLAME TEST WITH FILTERING ===");
      Serial.println("Hold a lighter under the flame rod to test detection");
      Serial.println("This will monitor flame detection with noise filtering");
      Serial.println("Press any key to stop...");
      Serial.println();
      
      Serial.println("Flame rod is ready - bring lighter close to flame rod probe");
      Serial.println("Format: Raw ADC | Filtered | Noise | Flame Status | Stability");
      Serial.println("============================================================");
      
      bool lastFlameState = false;
      int sampleCount = 0;
      
      // Reset filtering buffers for clean test
      for (int i = 0; i < 20; i++) {
        analogRead(FLAME_SENSE_PIN);
        delay(10);
      }
      
      while (!Serial.available()) {
        // Take multiple rapid readings to show filtering effect
        int rawTotal = 0;
        int samples = 5;
        for (int i = 0; i < samples; i++) {
          rawTotal += analogRead(FLAME_SENSE_PIN);
          delay(10);
        }
        int avgRaw = rawTotal / samples;
        
        bool currentFlame = readFlameStatus(); // This uses the filtered reading
        int filteredReading = burner.lastFlameReading;
        
        sampleCount++;
        
        Serial.print("Sample ");
        Serial.print(sampleCount);
        Serial.print(": Raw=");
        Serial.print(avgRaw);
        Serial.print(" | Filt=");
        Serial.print(filteredReading);
        Serial.print(" | Noise=");
        Serial.print(abs(avgRaw - filteredReading));
        Serial.print(" | ");
        Serial.print(currentFlame ? "üî• FLAME" : "‚ùÑÔ∏è none ");
        
        // Show when flame status changes
        if (currentFlame != lastFlameState) {
          if (currentFlame) {
            Serial.print(" | *** STABLE FLAME DETECTED! ***");
          } else {
            Serial.print(" | *** STABLE FLAME LOST ***");
          }
        }
        Serial.println();
        
        lastFlameState = currentFlame;
        delay(300); // ~3 samples per second
      }
      
      // Clear the serial buffer
      while (Serial.available()) Serial.read();
      Serial.println("\nLive flame test stopped");
      Serial.println("=============================");
    }
    else if (cmd == "noise_test") {
      Serial.println("=== NOISE ANALYSIS TEST ===");
      Serial.println("This will analyze signal noise and filtering effectiveness");
      Serial.println("Testing for 30 seconds with current conditions...");
      Serial.println();
      
      int totalSamples = 0;
      int noisySamples = 0;
      int maxNoise = 0;
      int minReading = 1024;
      int maxReading = 0;
      
      unsigned long startTime = millis();
      while (millis() - startTime < 30000) { // 30 seconds
        // Take rapid readings to measure noise
        int readings[10];
        for (int i = 0; i < 10; i++) {
          readings[i] = analogRead(FLAME_SENSE_PIN);
          delay(5);
        }
        
        // Calculate noise for this sample
        int minVal = 1024, maxVal = 0;
        for (int i = 0; i < 10; i++) {
          if (readings[i] < minVal) minVal = readings[i];
          if (readings[i] > maxVal) maxVal = readings[i];
          if (readings[i] < minReading) minReading = readings[i];
          if (readings[i] > maxReading) maxReading = readings[i];
        }
        
        int noise = maxVal - minVal;
        if (noise > maxNoise) maxNoise = noise;
        if (noise > MAX_NOISE_TOLERANCE) noisySamples++;
        totalSamples++;
        
        if (totalSamples % 20 == 0) {
          Serial.print("Sample ");
          Serial.print(totalSamples);
          Serial.print(": Noise=");
          Serial.print(noise);
          Serial.print(", Range=");
          Serial.print(minVal);
          Serial.print("-");
          Serial.print(maxVal);
          if (noise > MAX_NOISE_TOLERANCE) {
            Serial.print(" (NOISY!)");
          }
          Serial.println();
        }
        
        delay(200);
      }
      
      Serial.println("\n=== NOISE ANALYSIS RESULTS ===");
      Serial.print("Total samples: "); Serial.println(totalSamples);
      Serial.print("Noisy samples: "); Serial.print(noisySamples); 
      Serial.print(" ("); Serial.print((noisySamples * 100) / totalSamples); Serial.println("%)");
      Serial.print("Max noise level: "); Serial.println(maxNoise);
      Serial.print("Overall ADC range: "); Serial.print(minReading); 
      Serial.print(" to "); Serial.println(maxReading);
      Serial.print("Noise tolerance: "); Serial.println(MAX_NOISE_TOLERANCE);
      
      Serial.println("\n--- RECOMMENDATIONS ---");
      if (noisySamples > totalSamples / 4) {
        Serial.println("HIGH NOISE detected! Try:");
        Serial.println("1. Add 100nF capacitor from A0 to GND (close to ESP8266)");
        Serial.println("2. Use twisted pair or shielded cable for A0 connection");
        Serial.println("3. Keep A0 wire away from power lines and switching circuits");
        Serial.println("4. Check for loose connections in A0 circuit");
        Serial.println("5. Consider increasing STABILITY_REQUIRED to 5");
      } else if (noisySamples > totalSamples / 10) {
        Serial.println("MODERATE NOISE - current filtering should handle this");
      } else {
        Serial.println("LOW NOISE - signal is clean, filtering working well");
      }
      Serial.println("================================");
    }
    else if (cmd == "a0_test") {
      Serial.println("=== ENHANCED A0 PIN STABILITY TEST ===");
      Serial.println("Testing A0 pin with 20 readings for stability analysis");
      Serial.println("Format: Reading | ADC Value | Voltage | Status | Notes");
      Serial.println("=======================================================");
      
      int readings[20];
      int total = 0;
      int minVal = 1024, maxVal = 0;
      int stableCount = 0;
      
      for (int i = 0; i < 40; i++) {
        readings[i] = analogRead(FLAME_SENSE_PIN);
        total += readings[i];
        
        if (readings[i] < minVal) minVal = readings[i];
        if (readings[i] > maxVal) maxVal = readings[i];
        
        float voltage = (readings[i] * 3.3) / 1024.0;
        
        // Simple stability check - variation from average
        float avg = (float)total / (i + 1);
        bool isStable = abs(readings[i] - avg) < 5; // Arbitrary threshold for stability
        
        if (isStable) stableCount++;
        
        Serial.print(i + 1);
        Serial.print(" | ");
        Serial.print(readings[i]);
        Serial.print(" | ");
        Serial.print(voltage, 2);
        Serial.print("V | ");
        Serial.print(isStable ? "Stable" : "Unstable");
        Serial.print(" | ");
        if (readings[i] >= 1020) Serial.print("FLOATING PIN?");
        else if (readings[i] <= 10) Serial.print("GROUNDED?");
        else Serial.print("Normal");
        Serial.println();
        
        delay(200); // Delay between readings
      }
      
      float average = (float)total / 20.0;
      float variance = (maxVal - minVal);
      float stabilityPct = (float)stableCount / 20.0 * 100.0;
      
      Serial.println("\n=== A0 PIN ANALYSIS RESULTS ===");
      Serial.print("Average ADC: ");
      Serial.print(average, 1);
      Serial.print(" | Range: ");
      Serial.print(minVal);
      Serial.print("-");
      Serial.print(maxVal);
      Serial.print(" (Variance: ");
      Serial.print(variance);
      Serial.println(")");
      Serial.print("Stability: ");
      Serial.print(stableCount);
      Serial.print("/20 stable (");
      Serial.print(stabilityPct, 1);
      Serial.println("%)");
      
      Serial.println("\n--- ASSESSMENT ---");
      if (variance < 10) {
        if (average >= 1020) {
          Serial.println("PROBLEM: A0 pin floating (not connected)");
          Serial.println("FIX: Connect 1MŒ© resistor from A0 to GND");
        } else if (average <= 10) {
          Serial.println("PROBLEM: A0 pin grounded or shorted");
          Serial.println("CHECK: Wiring for shorts, remove direct GND connection");
        } else {
          Serial.println("GOOD: Very stable signal - low noise");
        }
      } else if (variance < 30) {
        Serial.println("GOOD: Acceptable stability - normal operation");
      } else {
        Serial.println("WARNING: High noise/variation - check:");
        Serial.println("1. Power supply stability");
        Serial.println("2. Wire length/shielding for A0");
        Serial.println("3. Add capacitor (100nF) A0 to GND");
        Serial.println("4. Interference from nearby circuits");
      }
      Serial.println("=============================");
    }
    else if (cmd == "flame_cal") {
      calibrateFlameRod();
    }
    else if (cmd == "flame_continuous") {
      Serial.println("=== CONTINUOUS FLAME MONITORING ===");
      Serial.println("Real-time flame sensor monitoring");
      Serial.println("Press any key to stop...");
      Serial.println("Format: Time | Raw ADC | Filtered | Flame Status");
      Serial.println("===============================================");
      
      unsigned long startTime = millis();
      while (!Serial.available()) {
        unsigned long elapsed = (millis() - startTime) / 1000;
        int rawReading = analogRead(FLAME_SENSE_PIN);
        bool flameStatus = readFlameStatus();
        int filteredReading = burner.lastFlameReading;
        
        Serial.print(elapsed);
        Serial.print("s | ");
        Serial.print(rawReading);
        Serial.print(" | ");
        Serial.print(filteredReading);
        Serial.print(" | ");
        Serial.println(flameStatus ? "üî• FLAME" : "‚ùÑÔ∏è none");
        
        delay(500);
      }
      while (Serial.available()) Serial.read();
      Serial.println("Continuous monitoring stopped");
      Serial.println("=============================");
    }
    else if (cmd == "wiring_test") {
      Serial.println("=== WIRING DIAGNOSTIC TEST ===");
      Serial.println("Testing A0 pin wiring and circuit integrity");
      Serial.println();
      
      Serial.println("Step 1: Testing A0 pin floating detection...");
      int floatingCount = 0;
      for (int i = 0; i < 5; i++) {
        int reading = analogRead(FLAME_SENSE_PIN);
        if (reading >= 1020) floatingCount++;
        Serial.print("Reading "); Serial.print(i+1); Serial.print(": "); Serial.println(reading);
        delay(200);
      }
      
      if (floatingCount >= 3) {
        Serial.println("‚ùå PROBLEM: A0 pin is floating (not connected)");
        Serial.println("FIX: Connect 1MŒ© resistor from A0 to GND");
      } else {
        Serial.println("‚úÖ GOOD: A0 pin properly connected");
      }
      
      Serial.println("\nStep 2: Testing flame rod output...");
      Serial.println("Setting GPIO5 HIGH...");
      digitalWrite(FLAME_ROD_OUT_PIN, HIGH);
      delay(100);
      int highReading = analogRead(FLAME_SENSE_PIN);
      
      Serial.println("Setting GPIO5 LOW...");
      digitalWrite(FLAME_ROD_OUT_PIN, LOW);
      delay(100);
      int lowReading = analogRead(FLAME_SENSE_PIN);
      
      Serial.print("GPIO5 HIGH -> A0: "); Serial.println(highReading);
      Serial.print("GPIO5 LOW -> A0: "); Serial.println(lowReading);
      Serial.print("Difference: "); Serial.println(highReading - lowReading);
      
      if (abs(highReading - lowReading) < 10) {
        Serial.println("‚ùå PROBLEM: No response to GPIO5 changes");
        Serial.println("CHECK: Flame rod connections, circuit continuity");
      } else {
        Serial.println("‚úÖ GOOD: A0 responds to GPIO5 changes");
      }
      
      Serial.println("\n=== WIRING RECOMMENDATIONS ===");
      Serial.println("Proper connections:");
      Serial.println("1. GPIO5 -> Flame rod probe");
      Serial.println("2. Flame rod -> A0 (via 1MŒ© resistor)");
      Serial.println("3. A0 -> GND (via 1MŒ© resistor)");
      Serial.println("4. ESP GND -> Burner chassis/ground");
      Serial.println("==============================");
    }
    else if (cmd == "glow_on") {
      setGlowPlug(true);
      Serial.println("GLOW PLUG: ON (Pin 4 -> HIGH -> 12V glow plug activated)");
    }
    else if (cmd == "glow_off") {
      setGlowPlug(false);
      Serial.println("GLOW PLUG: OFF (Pin 4 -> LOW -> 12V glow plug deactivated)");
    }
    else if (cmd == "glow_test") {
      Serial.println("=== GLOW PLUG CONTROL TEST ===");
      Serial.println("Testing 12V glow plug control via Pin 4");
      Serial.println("NOTE: Pin 4 outputs 3.3V signal to control 12V circuit");
      Serial.println();
      
      Serial.println("Step 1: Glow plug OFF...");
      setGlowPlug(false);
      Serial.print("Pin 4 state: "); Serial.println(digitalRead(MAIN_RELAY_PIN) ? "HIGH (3.3V)" : "LOW (0V)");
      delay(2000);
      
      Serial.println("Step 2: Glow plug ON...");
      setGlowPlug(true);
      Serial.print("Pin 4 state: "); Serial.println(digitalRead(MAIN_RELAY_PIN) ? "HIGH (3.3V)" : "LOW (0V)");
      Serial.println("Expected: 12V glow plug should be heating");
      delay(3000);
      
      Serial.println("Step 3: Glow plug OFF...");
      setGlowPlug(false);
      Serial.print("Pin 4 state: "); Serial.println(digitalRead(MAIN_RELAY_PIN) ? "HIGH (3.3V)" : "LOW (0V)");
      Serial.println("Expected: 12V glow plug should stop heating");
      
      Serial.println("\n=== GLOW PLUG TEST COMPLETE ===");
      Serial.println("Verify:");
      Serial.println("- Pin 4 changes between 0V and 3.3V");
      Serial.println("- 12V glow plug circuit responds to Pin 4");
      Serial.println("- Glow plug heats when Pin 4 is HIGH");
      Serial.println("===============================");
    }
    else if (cmd == "pin_test") {
      Serial.println("=== GPIO PIN OUTPUT TEST ===");
      Serial.println("Testing all control pins sequentially");
      Serial.println("Format: Pin | Function | State | Expected Output");
      Serial.println("==============================================");
      
      // Test each pin
      Serial.println("\n--- Testing Pilot Valve (Pin 2) ---");
      Serial.println("OFF:"); setPilotValve(false); 
      Serial.print("Pin 2: "); Serial.println(digitalRead(PILOT_RELAY_PIN) ? "HIGH" : "LOW");
      delay(1000);
      Serial.println("ON:"); setPilotValve(true);
      Serial.print("Pin 2: "); Serial.println(digitalRead(PILOT_RELAY_PIN) ? "HIGH" : "LOW");
      delay(1000);
      setPilotValve(false);
      
      Serial.println("\n--- Testing Glow Plug Control (Pin 4) ---");
      Serial.println("OFF:"); setGlowPlug(false);
      Serial.print("Pin 4: "); Serial.println(digitalRead(MAIN_RELAY_PIN) ? "HIGH" : "LOW");
      delay(1000);
      Serial.println("ON:"); setGlowPlug(true);
      Serial.print("Pin 4: "); Serial.println(digitalRead(MAIN_RELAY_PIN) ? "HIGH" : "LOW");
      delay(1000);
      setGlowPlug(false);
      
      Serial.println("\n--- Testing Flame Rod Output (Pin 5) ---");
      Serial.println("OFF:"); digitalWrite(FLAME_ROD_OUT_PIN, LOW);
      Serial.print("Pin 5: "); Serial.println(digitalRead(FLAME_ROD_OUT_PIN) ? "HIGH" : "LOW");
      delay(1000);
      Serial.println("ON:"); digitalWrite(FLAME_ROD_OUT_PIN, HIGH);
      Serial.print("Pin 5: "); Serial.println(digitalRead(FLAME_ROD_OUT_PIN) ? "HIGH" : "LOW");
      delay(1000);
      digitalWrite(FLAME_ROD_OUT_PIN, LOW);
      
      Serial.println("\n=== PIN TEST SUMMARY ===");
      Serial.println("Pin 2 (Pilot): Should control pilot valve relay");
      Serial.println("Pin 4 (Glow): Should control 12V glow plug circuit");
      Serial.println("Pin 5 (Flame Rod): Should output AC bias to flame rod");
      Serial.println("A0 (Flame Sense): Should read flame rectification signal");
      Serial.println("========================");
    }
    else if (cmd == "flame_diagnostic") {
      performCompleteFlameDiagnostic();
    }
    else if (cmd.length() > 0) {
      Serial.println("Unknown command. Type 'help' for available commands.");
    }
  }
}

// --- Web UI HTML (embedded) - Moved to PROGMEM to save RAM ---
const char PROGMEM webUI[] = R"rawliteral(
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>FlameWerks Burner Control</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 1em; background: #f5f5f5; }
    .container { max-width: 800px; margin: 0 auto; }
    h1 { text-align: center; color: #333; }
    .status-panel { background: white; padding: 1em; border-radius: 8px; margin: 1em 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .burner-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1em; margin: 1em 0; }
    .burner-card { background: white; padding: 1em; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .burner-status { font-size: 1.2em; font-weight: bold; margin: 0.5em 0; }
    .status-off { color: #d32f2f; }
    .status-igniting { color: #ff9800; animation: blink 1s infinite; }
    .status-on { color: #388e3c; }
    .status-fault { color: #d32f2f; background: #ffebee; padding: 0.2em; }
    @keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0.3; } }
    .controls { display: flex; gap: 0.5em; flex-wrap: wrap; margin: 1em 0; }
    .btn { padding: 0.7em 1.2em; border: none; border-radius: 4px; cursor: pointer; font-size: 1em; transition: background 0.2s; }
    .btn-primary { background: #1976d2; color: white; }
    .btn-primary:hover { background: #1565c0; }
    .btn-danger { background: #d32f2f; color: white; }
    .btn-danger:hover { background: #c62828; }
    .btn-secondary { background: #757575; color: white; }
    .btn-secondary:hover { background: #616161; }
    .emergency { background: #ffcdd2; border: 2px solid #d32f2f; padding: 1em; border-radius: 8px; margin: 1em 0; text-align: center; }
    .flame-indicator { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-left: 0.5em; }
    .flame-yes { background: #4caf50; }
    .flame-no { background: #f44336; }
  </style>
</head>
<body>
  <div class="container">
    <h1>FlameWerks Burner Control</h1>
    <div class="emergency">
      <button class="btn btn-danger" onclick="emergencyStop()">EMERGENCY STOP</button>
      <p>Immediately shuts off all valves and igniter</p>
    </div>
    <div class="status-panel">
      <h3>System Status</h3>
      <div id="systemStatus">Loading...</div>
    </div>
    <div class="burner-grid">
      <div class="burner-card">
        <h3>Burner 1</h3>
        <div id="burner1Status" class="burner-status">Loading...</div>
        <div id="burner1Flame">Flame: <span class="flame-indicator flame-no"></span></div>
        <div id="burner1Retries">Retries: 0/3</div>
        <div class="controls">
          <button class="btn btn-primary" onclick="startIgnition()">IGNITE</button>
          <button class="btn btn-danger" onclick="stopBurner()">STOP</button>
          <button class="btn btn-secondary" onclick="resetBurner()">RESET</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    setInterval(updateStatus, 2000);
    updateStatus();

    async function updateStatus() {
      try {
        const response = await fetch('/status');
        const burners = await response.json();
        const burner = burners[0];
        
        const statusEl = document.getElementById('burner1Status');
        const flameEl = document.getElementById('burner1Flame');
        const retriesEl = document.getElementById('burner1Retries');
        
        let statusClass = '';
        let statusText = '';
        switch(burner.state) {
          case 'off': statusClass = 'status-off'; statusText = 'OFF'; break;
          case 'igniting': statusClass = 'status-igniting'; statusText = 'IGNITING PILOT...'; break;
          case 'pilot-running': statusClass = 'status-on'; statusText = 'PILOT RUNNING (TEST)'; break;
          case 'flameout': statusClass = 'status-fault'; statusText = 'FLAMEOUT'; break;
          case 'fault': statusClass = 'status-fault'; statusText = 'FAULT - RESET REQUIRED'; break;
          default: statusClass = 'status-off'; statusText = 'UNKNOWN'; break;
        }
        
        statusEl.className = 'burner-status ' + statusClass;
        statusEl.textContent = statusText;
        
        const flameIndicator = flameEl.querySelector('.flame-indicator');
        flameIndicator.className = 'flame-indicator ' + (burner.flame ? 'flame-yes' : 'flame-no');
        flameEl.innerHTML = 'Flame: <span class="flame-indicator ' + (burner.flame ? 'flame-yes' : 'flame-no') + '"></span> ' + (burner.flame ? 'DETECTED' : 'NONE') + ' (ADC: ' + (burner.flameSensorValue || 'N/A') + ')';
        
        retriesEl.textContent = 'Attempts: ' + burner.attempts + '/' + burner.maxAttempts;
        
        document.getElementById('systemStatus').textContent = 
          'Burner 1: ' + statusText + ' | Flame: ' + (burner.flame ? 'Detected' : 'None') + ' | IP: ' + location.hostname;
          
      } catch (error) {
        console.error('Status update failed:', error);
        document.getElementById('systemStatus').textContent = 'Connection Error - Check firmware';
      }
    }

    async function sendCommand(cmd) {
      try {
        const response = await fetch('/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: 'cmd=' + cmd
        });
        const result = await response.text();
        console.log('Command result:', result);
        document.getElementById('systemStatus').textContent = result;
        setTimeout(updateStatus, 500);
      } catch (error) {
        console.error('Command failed:', error);
        alert('Command failed - check ESP8266 connection');
      }
    }

    function startIgnition() { 
      if (confirm('Start ignition sequence?')) {
        sendCommand('ignite'); 
      }
    }
    function stopBurner() { 
      if (confirm('Emergency shutdown?')) {
        sendCommand('stop'); 
      }
    }
    function resetBurner() { 
      if (confirm('Reset system from FAULT state?')) {
        sendCommand('reset'); 
      }
    }
    function emergencyStop() { 
      if (confirm('EMERGENCY STOP will immediately shut off all systems!')) {
        sendCommand('stop'); 
      }
    }
  </script>
</body>
</html>
)rawliteral";

String getWebUI() {
  return FPSTR(webUI);
}

// --- Setup Function ---
void setup() {
  // Initialize serial communication
  Serial.begin(115200);
  Serial.println("\n=== FlameWerks Remote Burner Control System ===");
  Serial.println("ESP8266 Thing Dev - Auburn I-31-2 Compatible");
  
  // Initialize GPIO pins
  pinMode(PILOT_RELAY_PIN, OUTPUT);
  pinMode(MAIN_RELAY_PIN, OUTPUT);  // Pin 4 - Now enabled for glow plug control
  pinMode(FLAME_ROD_OUT_PIN, OUTPUT);
  
  // Ensure all outputs start OFF
  setPilotValve(false);
  setMainValve(false);
  setGlowPlug(false);  // Initialize glow plug to OFF
  
  // Initialize burner controller
  burner.state = OFF;
  burner.stateStartTime = millis();
  burner.retryAttempt = 0;
  burner.flameDetected = false;
  burner.igniterActive = false;
  burner.pilotValveOpen = false;
  burner.mainValveOpen = false;
  
  Serial.println("Hardware initialized - Single relay testing mode");
  Serial.println("WARNING: PILOT VALVE ONLY - Main valve simulated");
  Serial.println("   Connect 2nd relay to GPIO4 for full operation");
  Serial.println("   Flame rod is PASSIVE RECEIVER ONLY");
  
  // Connect to WiFi
  WiFi.mode(WIFI_STA);
  WiFi.hostname(hostname);
  WiFi.begin(ssid, password);
  
  Serial.print("Connecting to WiFi");
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi connected successfully!");
    Serial.print("IP address: ");
    Serial.println(WiFi.localIP());
    Serial.print("Hostname: ");
    Serial.println(hostname);
    
    // Start mDNS responder
    if (MDNS.begin(hostname)) {
      Serial.println("mDNS responder started");
      Serial.print("Access via: http://");
      Serial.print(hostname);
      Serial.println(".local/");
    }
  } else {
    Serial.println("\nWiFi connection failed!");
    Serial.println("System will continue in offline mode");
  }
  
  // Configure web server routes
  server.on("/", HTTP_GET, handleRoot);
  server.on("/status", HTTP_GET, handleStatus);
  server.on("/control", HTTP_POST, handleControl);
  server.onNotFound(handleNotFound);
  
  // Start web server
  server.begin();
  Serial.println("Web server started on port 80");
  
  Serial.println("\n=== System Ready ===");
  Serial.println("Commands: i=ignite, e=stop, r=reset, s=status, help");
  Serial.println("Web UI: http://" + WiFi.localIP().toString() + "/");
  Serial.println("========================\n");
}

// --- Main Loop ---
void loop() {
  // Handle web server requests
  server.handleClient();
  
  // Handle mDNS
  MDNS.update();
  
  // Handle serial commands
  handleSerialCommands();
  
  // Update burner state machine
  updateBurnerStateMachine();
  
  // Small delay to prevent excessive CPU usage
  delay(50);
}

// --- Enhanced Flame Rod Testing Functions ---
void performADCDiagnostic() {
  Serial.println("=== ADC DIAGNOSTIC - FINDING THE PROBLEM ===");
  Serial.println("Your stability test shows ADC readings of 0 but filtered values >100");
  Serial.println("This indicates a serious ADC or connection problem");
  Serial.println("===============================================");
  
  Serial.println("\n*** STEP 1: BASIC ADC FUNCTIONALITY TEST ***");
  Serial.println("Testing if ADC can read anything at all...");
  
  // Test ADC with different methods
  for (int i = 0; i < 10; i++) {
    int reading1 = analogRead(A0);
    delay(10);
    int reading2 = analogRead(FLAME_SENSE_PIN);
    delay(10);
    
    Serial.print("Test "); Serial.print(i+1); Serial.print(": ");
    Serial.print("analogRead(A0)="); Serial.print(reading1);
    Serial.print(" | analogRead(FLAME_SENSE_PIN)="); Serial.print(reading2);
    
    if (reading1 == 0 && reading2 == 0) {
      Serial.print(" ‚ùå BOTH ZERO - ADC PROBLEM!");
    } else if (reading1 != reading2) {
      Serial.print(" ‚ö†Ô∏è DIFFERENT VALUES - TIMING ISSUE");
    } else {
      Serial.print(" ‚úÖ NORMAL");
    }
    Serial.println();
    delay(500);
  }
  
  Serial.println("\n*** STEP 2: PIN CONFIGURATION CHECK ***");
  Serial.print("FLAME_SENSE_PIN defined as: "); Serial.println(FLAME_SENSE_PIN);
  Serial.print("This should equal A0 ("); Serial.print(A0); Serial.println(")");
  
  if (FLAME_SENSE_PIN != A0) {
    Serial.println("‚ùå CRITICAL: Pin definition mismatch!");
    Serial.println("FLAME_SENSE_PIN should be A0");
  } else {
    Serial.println("‚úÖ Pin definition is correct");
  }
  
  Serial.println("\n*** STEP 3: RAPID SAMPLING TEST ***");
  Serial.println("Taking 100 rapid samples to see if ADC is stuck...");
  
  int zeroCount = 0;
  int maxVal = 0;
  int minVal = 1024;
  
  for (int i = 0; i < 100; i++) {
    int reading = analogRead(A0);
    if (reading == 0) zeroCount++;
    if (reading > maxVal) maxVal = reading;
    if (reading < minVal) minVal = reading;
    delay(10);
  }
  
  Serial.print("Zero readings: "); Serial.print(zeroCount); Serial.println("/100");
  Serial.print("Min value: "); Serial.println(minVal);
  Serial.print("Max value: "); Serial.println(maxVal);
  Serial.print("Range: "); Serial.println(maxVal - minVal);
  
  if (zeroCount == 100) {
    Serial.println("‚ùå CRITICAL: ADC always reads 0!");
    Serial.println("POSSIBLE CAUSES:");
    Serial.println("1. A0 pin is damaged or not connected");
    Serial.println("2. ESP8266 ADC is faulty");
    Serial.println("3. Pin is configured as digital output instead of analog input");
    Serial.println("4. External short circuit to ground");
  } else if (zeroCount > 50) {
    Serial.println("‚ö†Ô∏è WARNING: ADC frequently reads 0 - intermittent connection");
  } else if (maxVal == minVal) {
    Serial.println("‚ö†Ô∏è WARNING: ADC reading is stuck at one value");
  } else {
    Serial.println("‚úÖ ADC appears to be working - values vary");
  }
  
  Serial.println("\n*** STEP 4: PHYSICAL CONNECTION TEST ***");
  Serial.println("Testing if touching A0 pin changes readings...");
  Serial.println("When prompted, briefly touch A0 pin with your finger");
  delay(2000);
  
  Serial.println("Baseline (don't touch):");
  int baseline = 0;
  for (int i = 0; i < 5; i++) {
    int reading = analogRead(A0);
    baseline += reading;
    Serial.print("  "); Serial.println(reading);
    delay(200);
  }
  baseline /= 5;
  
  Serial.println("Now TOUCH the A0 pin with your finger for 3 seconds...");
  delay(1000);
  
  int touchedSum = 0;
  for (int i = 0; i < 10; i++) {
    int reading = analogRead(A0);
    touchedSum += reading;
    Serial.print("  Touch "); Serial.print(i+1); Serial.print(": "); Serial.println(reading);
    delay(300);
  }
  int touchedAvg = touchedSum / 10;
  
  Serial.print("Baseline average: "); Serial.println(baseline);
  Serial.print("Touched average: "); Serial.println(touchedAvg);
  Serial.print("Difference: "); Serial.println(abs(touchedAvg - baseline));
  
  if (abs(touchedAvg - baseline) < 5) {
    Serial.println("‚ùå CRITICAL: No change when touching A0 - pin not working!");
    Serial.println("SOLUTIONS:");
    Serial.println("1. Check A0 pin is properly connected to breadboard");
    Serial.println("2. Try different ESP8266 board");
    Serial.println("3. Verify wiring to A0 pin");
  } else {
    Serial.println("‚úÖ GOOD: A0 pin responds to touch - hardware is working");
  }
  
  Serial.println("\n*** STEP 5: FILTERING ALGORITHM DEBUG ***");
  Serial.println("The filtering algorithm might be using old/corrupt data");
  Serial.println("Let's examine what's happening inside the filter...");
  
  // Reset the filter and watch it
  Serial.println("Taking 20 readings and showing filter progression:");
  for (int i = 0; i < 20; i++) {
    int rawReading = analogRead(A0);
    bool flameStatus = readFlameStatus();
    int filteredReading = burner.lastFlameReading;
    
    Serial.print("Reading "); Serial.print(i+1); Serial.print(": ");
    Serial.print("Raw="); Serial.print(rawReading);
    Serial.print(" | Filtered="); Serial.print(filteredReading);
    Serial.print(" | Flame="); Serial.println(flameStatus ? "YES" : "NO");
    delay(500);
  }
  
  Serial.println("\n=== DIAGNOSTIC CONCLUSIONS ===");
  
  if (zeroCount == 100) {
    Serial.println("üö® HARDWARE FAILURE: A0 pin is not working");
    Serial.println("IMMEDIATE ACTIONS:");
    Serial.println("1. Check physical connection to A0 pin");
    Serial.println("2. Try a different ESP8266 board");
    Serial.println("3. Verify no short circuits");
  } else if (zeroCount > 10) {
    Serial.println("‚ö†Ô∏è INTERMITTENT PROBLEM: Loose connections");
    Serial.println("FIXES:");
    Serial.println("1. Re-solder connections to A0 pin");
    Serial.println("2. Check breadboard contacts");
    Serial.println("3. Use shorter, more stable wires");
  } else {
    Serial.println("ü§î SOFTWARE ISSUE: ADC works but filtering has problems");
    Serial.println("The issue is likely in the filtering algorithm or buffer corruption");
    Serial.println("Try restarting the ESP8266 to reset all static variables");
  }
  
  Serial.println("\n=== ADC DIAGNOSTIC COMPLETE ===");
}

void performStabilityTest() {
  Serial.println("=== ENHANCED STABILITY TEST WITH IMPROVED FILTERING ===");
  Serial.println("Testing new filtering algorithm for 60 seconds");
  Serial.println("This test has 2 phases - follow instructions carefully");
  Serial.println("");
  Serial.println("‚ö†Ô∏è  IMPORTANT: If you suspect filter corruption, restart ESP8266 first!");
  Serial.println("   (Press reset button or disconnect/reconnect power)");
  Serial.println("");
  Serial.println("Format: Time | Raw | Filtered | Average | Noise | Flame");
  Serial.println("======================================================");
  
  Serial.println("PHASE 1: No flame baseline (30 seconds)...");
  Serial.println("Make sure NO flame is near the sensor!");
  delay(3000); // Give time to move flame away
  
  unsigned long testStart = millis();
  int baselineSum = 0;
  int baselineCount = 0;
  int maxNoise = 0;
  
  while (millis() - testStart < 30000) {
    unsigned long elapsed = (millis() - testStart) / 1000;
    int rawReading = analogRead(FLAME_SENSE_PIN);
    bool flameStatus = readFlameStatus();
    int avgReading = burner.lastFlameReading;
    
    baselineSum += avgReading;
    baselineCount++;
    
    // Print every 5 seconds
    if (elapsed % 5 == 0 && (millis() - testStart) % 1000 < 100) {
      Serial.print(elapsed); Serial.print("s | ");
      Serial.print(rawReading); Serial.print(" | ");
      Serial.print("--"); Serial.print(" | ");
      Serial.print(avgReading); Serial.print(" | ");
      Serial.print("--"); Serial.print(" | ");
      Serial.println(flameStatus ? "üî•" : "‚ùÑÔ∏è");
    }
    delay(100);
  }
  
  int baselineAvg = baselineSum / baselineCount;
  Serial.print("BASELINE AVERAGE: "); Serial.println(baselineAvg);
  
  if (baselineAvg > 50) {
    Serial.println("‚ö†Ô∏è  WARNING: High baseline - check for interference or floating A0");
  } else if (baselineAvg >= 1020) {
    Serial.println("‚ùå CRITICAL: A0 pin is FLOATING! Connect 1MŒ© resistor from A0 to GND");
    return;
  } else {
    Serial.println("‚úÖ GOOD: Baseline is acceptable");
  }
  
  Serial.println("\nPHASE 2: Light and hold flame near rod (30 seconds)...");
  Serial.println("Light your lighter NOW and hold flame close to flame rod...");
  delay(3000); // Give time to light flame
  
  testStart = millis();
  int flameSum = 0;
  int flameCount = 0;
  int flameDetections = 0;
  int maxFlameReading = 0;
  
  while (millis() - testStart < 30000) {
    unsigned long elapsed = (millis() - testStart) / 1000;
    int rawReading = analogRead(FLAME_SENSE_PIN);
    bool flameStatus = readFlameStatus();
    int avgReading = burner.lastFlameReading;
    
    flameSum += avgReading;
    flameCount++;
    if (flameStatus) flameDetections++;
    if (avgReading > maxFlameReading) maxFlameReading = avgReading;
    
    // Print every 2 seconds during flame test
    if (elapsed % 2 == 0 && (millis() - testStart) % 1000 < 100) {
      Serial.print(elapsed); Serial.print("s | ");
      Serial.print(rawReading); Serial.print(" | ");
      Serial.print("--"); Serial.print(" | ");
      Serial.print(avgReading); Serial.print(" | ");
      Serial.print("--"); Serial.print(" | ");
      Serial.print(flameStatus ? "üî•" : "‚ùÑÔ∏è");
      if (avgReading > baselineAvg + 20) Serial.print(" GOOD!");
      Serial.println();
    }
    delay(100);
  }
  
  int flameAvg = flameSum / flameCount;
  int signalIncrease = maxFlameReading - baselineAvg;
  
  Serial.println("\n=== STABILITY TEST RESULTS ===");
  Serial.println("================================");
  Serial.print("Baseline average: "); Serial.println(baselineAvg);
  Serial.print("Flame average: "); Serial.println(flameAvg);
  Serial.print("Max flame reading: "); Serial.println(maxFlameReading);
  Serial.print("Signal increase: "); Serial.println(signalIncrease);
  Serial.print("Flame detections: "); Serial.print(flameDetections); 
  Serial.print("/"); Serial.println(flameCount);
  Serial.print("Detection rate: "); Serial.print((flameDetections * 100) / flameCount); Serial.println("%");
  Serial.print("Current threshold: "); Serial.println(FLAME_DETECTION_THRESHOLD);
  
  Serial.println("\n--- ASSESSMENT ---");
  
  if (signalIncrease < 15) {
    Serial.println("‚ùå POOR: Very weak flame signal");
    Serial.println("SOLUTIONS:");
    Serial.println("1. Hold flame closer to flame rod probe");
    Serial.println("2. Check 1MŒ© resistor value (must be 1 megohm, not 1k!)");
    Serial.println("3. Verify flame rod is metallic and conductive");
    Serial.println("4. Connect ESP GND to burner/lighter chassis for ground reference");
  } else if (signalIncrease < 30) {
    Serial.println("‚ö†Ô∏è  MARGINAL: Weak but detectable signal");
    Serial.println("IMPROVEMENTS:");
    Serial.println("1. Position flame rod closer to flame");
    Serial.println("2. Ensure good ground connection to burner/lighter");
    Serial.println("3. Try lower threshold: " + String(baselineAvg + 10));
  } else {
    Serial.println("‚úÖ EXCELLENT: Strong flame signal detected!");
    Serial.println("Your improved filtering is working well!");
  }
  
  if (flameDetections > (flameCount * 0.8)) {
    Serial.println("‚úÖ EXCELLENT: Very stable flame detection");
  } else if (flameDetections > (flameCount * 0.6)) {
    Serial.println("‚úÖ GOOD: Stable flame detection");
  } else if (flameDetections > (flameCount * 0.3)) {
    Serial.println("‚ö†Ô∏è  MARGINAL: Intermittent detection - improve signal");
  } else {
    Serial.println("‚ùå POOR: Unreliable detection");
  }
  
  Serial.println("\n--- FILTERING PERFORMANCE ---");
  Serial.println("The new filtering algorithm includes:");
  Serial.println("‚úì 8-sample outlier rejection per reading");
  Serial.println("‚úì 16-sample moving average");
  Serial.println("‚úì Adaptive threshold based on noise level");
  Serial.println("‚úì 5 stable readings required to detect flame");
  Serial.println("‚úì 3 stable readings required to lose flame");
  Serial.println("‚úì Rate limiting to reduce noise susceptibility");
  
  Serial.println("\n--- NEXT STEPS ---");
  if (signalIncrease >= 20 && flameDetections > (flameCount * 0.6)) {
    Serial.println("üéâ SUCCESS! Your improved flame sensor is working!");
    Serial.println("The enhanced filtering has made it much more stable.");
    Serial.println("Try command 'ignite' to test full system.");
  } else {
    Serial.println("üîß HARDWARE ISSUES REMAIN:");
    Serial.println("1. Fix wiring issues identified above");
    Serial.println("2. Re-run this test: 'stability_test'");
    Serial.println("3. Try 'flame_diagnostic' for detailed troubleshooting");
  }
  
  Serial.println("\n=== STABILITY TEST COMPLETE ===");
}

void testFlameRodDetailed() {
  Serial.println("\n=== DETAILED FLAME ROD TEST ===");
  Serial.println("Testing flame rectification circuit...");
  Serial.println("Format: Sample | ADC | Status | Output");
  Serial.println("=====================================");
  
  int total = 0;
  int minVal = 1024;
  int maxVal = 0;
  int flameCount = 0;
  
  for (int i = 0; i < 20; i++) {
    int reading = analogRead(FLAME_SENSE_PIN);
    bool detected = reading > FLAME_DETECTION_THRESHOLD;
    bool rodActive = digitalRead(FLAME_ROD_OUT_PIN);
    
    total += reading;
    if (reading < minVal) minVal = reading;
    if (reading > maxVal) maxVal = reading;
    if (detected) flameCount++;
    
    Serial.print("  ");
    Serial.print(i + 1);
    Serial.print("   | ");
    Serial.print(reading);
    if (reading < 100) Serial.print(" ");
    if (reading < 10) Serial.print(" ");
    Serial.print(" | ");
    Serial.print(detected ? "FLAME" : "none ");
    Serial.print(" | ");
    Serial.println(rodActive ? "3.3V" : "0V");
    
    delay(500);
  }
  
  int average = total / 20;
  
  Serial.println("\n--- FLAME ROD ANALYSIS ---");
  Serial.print("Average: ");
  Serial.print(average);
  Serial.print(" | Range: ");
  Serial.print(minVal);
  Serial.print("-");
  Serial.print(maxVal);
  Serial.print(" | Span: ");
  Serial.println(maxVal - minVal);
  Serial.print("Threshold: ");
  Serial.print(FLAME_DETECTION_THRESHOLD);
  Serial.print(" | Detection rate: ");
  Serial.print(flameCount);
  Serial.print("/20 (");
  Serial.print((flameCount * 100) / 20);
  Serial.println("%)");
  
  Serial.println("\n--- CIRCUIT ASSESSMENT ---");
  if (maxVal - minVal < 30) {
    Serial.println("WARNING: Very low variation - check flame rod wiring");
    Serial.println("   - Verify 1MŒ© resistor connection");
    Serial.println("   - Check flame rod probe contact");
  } else if (maxVal - minVal > 100) {
    Serial.println("GOOD: Good signal variation - flame rod working");
  } else {
    Serial.println("INFO: Moderate variation - acceptable operation");
  }
  
  if (average < 30) {
    Serial.println("INFO: Low baseline - good for flame detection");
  } else if (average > 100) {
    Serial.println("WARNING: High baseline - may need threshold adjustment");
  }
  
  Serial.println("===============================");
}

void calibrateFlameRod() {
  Serial.println("\n=== FLAME ROD CALIBRATION ===");
  Serial.println("This will determine optimal flame detection threshold");
  Serial.println("NOTE: Flame rod is passive receiver only");
  
  // Step 1: No flame reading
  Serial.println("\nSTEP 1: NO FLAME BASELINE");
  Serial.println("Ensure no flame or heat source is near the flame rod...");
  delay(2000);
  
  Serial.println("Taking baseline readings (no flame)...");
  int noFlameTotal = 0;
  for (int i = 0; i < 10; i++) {
    int reading = analogRead(FLAME_SENSE_PIN);
    noFlameTotal += reading;
    Serial.print("No flame ");
    Serial.print(i + 1);
    Serial.print(": ");
    Serial.println(reading);
    delay(300);
  }
  int noFlameAverage = noFlameTotal / 10;
  
  Serial.print("GOOD: No flame average: ");
  Serial.println(noFlameAverage);
  
  // Step 2: With flame reading
  Serial.println("\nSTEP 2: FLAME DETECTION");
  Serial.println("Light flame near flame rod probe...");
  Serial.println("Press any key when flame is stable...");
  
  while (!Serial.available()) {
    int reading = analogRead(FLAME_SENSE_PIN);
    Serial.print("Current reading: ");
    Serial.print(reading);
    Serial.print(" (bring flame closer to rod)");
    delay(1000);
  }
  while (Serial.available()) Serial.read(); // Clear buffer
  
  Serial.println("Taking flame readings...");
  int flameTotal = 0;
  for (int i = 0; i < 10; i++) {
    int reading = analogRead(FLAME_SENSE_PIN);
    flameTotal += reading;
    Serial.print("With flame ");
    Serial.print(i + 1);
    Serial.print(": ");
    Serial.println(reading);
    delay(300);
  }
  int flameAverage = flameTotal / 10;
  
  Serial.print("GOOD: Flame average: ");
  Serial.println(flameAverage);
  
  // Calculate results
  int difference = flameAverage - noFlameAverage;
  int recommendedThreshold = noFlameAverage + (difference / 3); // 33% above baseline
  
  Serial.println("\n--- CALIBRATION RESULTS ---");
  Serial.print("No flame: ");
  Serial.print(noFlameAverage);
  Serial.print(" | With flame: ");
  Serial.println(flameAverage);
  Serial.print("Difference: ");
  Serial.print(difference);
  Serial.print(" | Ratio: ");
  if (noFlameAverage > 0) {
    Serial.print((float)flameAverage / noFlameAverage, 1);
    Serial.println(":1");
  } else {
    Serial.println("N/A");
  }
  
  Serial.print("Current threshold: ");
  Serial.println(FLAME_DETECTION_THRESHOLD);
  Serial.print("Recommended threshold: ");
  Serial.println(recommendedThreshold);
  
  if (difference < 20) {
    Serial.println("\nPOOR: Very small flame signal");
    Serial.println("   Check: Flame rod position, 1MŒ© resistor, connections");
    Serial.println("   Try holding flame closer to the rod probe");
  } else if (difference < 50) {
    Serial.println("\nWARNING: MARGINAL: Weak flame signal");
    Serial.println("   Consider: Better flame rod positioning closer to flame");
  } else {
    Serial.println("\nGOOD: Strong flame rectification signal");
  }
  
  Serial.println("\n--- UPDATE FIRMWARE ---");
  Serial.println("To use new threshold, change this line:");
  Serial.print("const int FLAME_DETECTION_THRESHOLD = ");
  Serial.print(recommendedThreshold);
  Serial.println(";");
  Serial.println("============================");
}

// --- Flame Rod Level Testing Function ---
void testFlameRodLevels() {
  Serial.println("\n=== FLAME ROD OUTPUT LEVEL TEST ===");
  Serial.println("Testing different flame rod output levels...");
  Serial.println("This simulates different flame intensities for sensor calibration");
  Serial.println("Format: Level | Output | ADC Reading | Detected | Notes");
  Serial.println("========================================================");
  
  // Test each level for 3 seconds with readings
  int levels[] = {0, 1, 2, 3, 4};
  String levelNames[] = {"OFF", "LOW", "MEDIUM", "HIGH", "FULL"};
  String voltages[] = {"0V", "~0.8V", "~1.6V", "~2.5V", "3.3V"};
  
  for (int i = 0; i < 5; i++) {
    Serial.print("\n--- Testing Level ");
    Serial.print(levels[i]);
    Serial.print(" (");
    Serial.print(levelNames[i]);
    Serial.print(" - ");
    Serial.print(voltages[i]);
    Serial.println(") ---");
    
    setFlameRodOutputLevel(levels[i]);
    delay(500); // Let output stabilize
    
    // Take 5 readings over 2.5 seconds
    int total = 0;
    int maxReading = 0;
    int minReading = 1024;
    int detectedCount = 0;
    
    for (int j = 0; j < 5; j++) {
      int reading = analogRead(FLAME_SENSE_PIN);
      bool detected = reading > FLAME_DETECTION_THRESHOLD;
      
      total += reading;
      if (reading > maxReading) maxReading = reading;
      if (reading < minReading) minReading = reading;
      if (detected) detectedCount++;
      
      Serial.print("  Reading ");
      Serial.print(j + 1);
      Serial.print(": ");
      Serial.print(reading);
      Serial.print(" | ");
      Serial.print(detected ? "FLAME" : "none ");
      
      if (j == 0) {
        // Add interpretation for first reading
        if (levels[i] == 0 && reading < 20) {
          Serial.print(" | GOOD: Good baseline");
        } else if (levels[i] > 0 && reading > FLAME_DETECTION_THRESHOLD) {
          Serial.print(" | GOOD: Good flame signal");
        } else if (levels[i] > 0 && reading <= FLAME_DETECTION_THRESHOLD) {
          Serial.print(" | WARNING: Weak signal");
        }
      }
      Serial.println();
      
      delay(500);
    }
    
    int average = total / 5;
    Serial.print("  Summary - Avg: ");
    Serial.print(average);
    Serial.print(" | Range: ");
    Serial.print(minReading);
    Serial.print("-");
    Serial.print(maxReading);
    Serial.print(" | Detection: ");
    Serial.print(detectedCount);
    Serial.println("/5");
    
    // Analysis
    if (levels[i] == 0) {
      if (average < 30) {
        Serial.println("  GOOD: Good baseline - low noise");
      } else {
        Serial.println("  WARNING: High baseline - check wiring");
      }
    } else {
      int signalIncrease = average - 20; // Assume ~20 baseline
      if (signalIncrease > 50) {
        Serial.println("  GOOD: Strong signal increase");
      } else if (signalIncrease > 20) {
        Serial.println("  INFO: Moderate signal increase");
      } else {
        Serial.println("  PROBLEM: Weak signal - check circuit");
      }
    }
  }
  
  Serial.println("\n=== TEST COMPLETE ===");
  Serial.println("Analysis:");
  Serial.println("- Level 0 should show low baseline readings");
  Serial.println("- Higher levels should show increasing ADC values");
  Serial.println("- Flame detection should trigger at higher levels");
  Serial.println("- If all levels show similar readings, check:");
  Serial.println("  * 1MŒ© resistor connection");
  Serial.println("  * A0 pin wiring");
  Serial.println("  * GPIO5 output circuit");
  
  // Return to OFF state
  setFlameRodOutputLevel(0);
  Serial.println("\nFlame rod output returned to OFF");
  Serial.println("=============================");
}

void setFlameRodOutputLevel(int level) {
  // Set flame rod output level (0-4)
  // Level 0 = OFF (0V), Level 4 = FULL (3.3V)
  if (level <= 0) {
    digitalWrite(FLAME_ROD_OUT_PIN, LOW);
  } else {
    // For levels 1-4, we'll use digital HIGH (3.3V)
    // In a more advanced implementation, you could use analogWrite() for PWM
    digitalWrite(FLAME_ROD_OUT_PIN, HIGH);
  }
}

// Add new diagnostic function before setup()
void performCompleteFlameDiagnostic() {
  Serial.println("\n=== COMPLETE FLAME SENSOR DIAGNOSTIC ===");
  Serial.println("This will test ALL aspects of your flame sensing system");
  Serial.println("Follow the steps carefully and report results");
  Serial.println("===============================================");
  
  // Step 1: Hardware Check
  Serial.println("\n*** STEP 1: HARDWARE WIRING CHECK ***");
  Serial.println("Verify these connections:");
  Serial.println("1. GPIO5 (Pin D1) -> Flame rod probe");
  Serial.println("2. Flame rod -> A0 (via 1MŒ© resistor)");
  Serial.println("3. 1MŒ© resistor from A0 to GND");
  Serial.println("4. ESP8266 GND -> Burner chassis/metal ground");
  Serial.println("Press any key when wiring is verified...");
  
  while (!Serial.available()) delay(100);
  while (Serial.available()) Serial.read();
  
  // Step 2: A0 Baseline Test
  Serial.println("\n*** STEP 2: A0 BASELINE TEST ***");
  Serial.println("Testing A0 with no flame present...");
  
  int baselineTotal = 0;
  int floatingCount = 0;
  for (int i = 0; i < 10; i++) {
    int reading = analogRead(FLAME_SENSE_PIN);
    baselineTotal += reading;
    if (reading >= 1020) floatingCount++;
    
    Serial.print("Baseline "); Serial.print(i+1); Serial.print(": ");
    Serial.print(reading);
    if (reading >= 1020) Serial.print(" (FLOATING!)");
    else if (reading <= 5) Serial.print(" (GROUNDED)");
    Serial.println();
    delay(300);
  }
  
  int baselineAvg = baselineTotal / 10;
  Serial.print("\nBaseline Average: "); Serial.println(baselineAvg);
  
  if (floatingCount >= 5) {
    Serial.println("‚ùå CRITICAL: A0 pin is FLOATING!");
    Serial.println("   FIX: Connect 1MŒ© resistor from A0 to GND");
    Serial.println("   This is the most common problem!");
    return;
  } else if (baselineAvg > 100) {
    Serial.println("‚ö†Ô∏è  WARNING: High baseline - check for interference");
  } else {
    Serial.println("‚úÖ GOOD: A0 baseline is acceptable");
  }
  
  // Step 3: GPIO5 Output Test
  Serial.println("\n*** STEP 3: GPIO5 OUTPUT TEST ***");
  Serial.println("Testing GPIO5 flame rod output...");
  
  Serial.println("Setting GPIO5 LOW...");
  digitalWrite(FLAME_ROD_OUT_PIN, LOW);
  delay(200);
  int lowReading = analogRead(FLAME_SENSE_PIN);
  
  Serial.println("Setting GPIO5 HIGH...");
  digitalWrite(FLAME_ROD_OUT_PIN, HIGH);
  delay(200);
  int highReading = analogRead(FLAME_SENSE_PIN);
  
  digitalWrite(FLAME_ROD_OUT_PIN, LOW); // Return to safe state
  
  Serial.print("GPIO5 LOW -> A0: "); Serial.println(lowReading);
  Serial.print("GPIO5 HIGH -> A0: "); Serial.println(highReading);
  Serial.print("Difference: "); Serial.println(highReading - lowReading);
  
  if (abs(highReading - lowReading) < 10) {
    Serial.println("‚ùå PROBLEM: GPIO5 not affecting A0 reading");
    Serial.println("   CHECK: Flame rod connections, circuit continuity");
    Serial.println("   Verify flame rod is connected to both GPIO5 and A0");
  } else {
    Serial.println("‚úÖ GOOD: GPIO5 output affects A0 reading");
  }
  
  // Step 4: Live Flame Test
  Serial.println("\n*** STEP 4: LIVE FLAME TEST ***");
  Serial.println("Now test with actual flame...");
  Serial.println("1. Light a lighter or candle");
  Serial.println("2. Hold flame close to flame rod probe");
  Serial.println("3. Watch for readings above threshold (25)");
  Serial.println("Press any key to start 30-second flame test...");
  
  while (!Serial.available()) delay(100);
  while (Serial.available()) Serial.read();
  
  Serial.println("\nStarting 30-second flame test...");
  Serial.println("Format: Time | Raw ADC | Filtered | Above Threshold?");
  Serial.println("================================================");
  
  unsigned long testStart = millis();
  int maxFlameReading = 0;
  int flameDetections = 0;
  
  while (millis() - testStart < 30000) {
    unsigned long elapsed = (millis() - testStart) / 1000;
    int rawReading = analogRead(FLAME_SENSE_PIN);
    bool flameStatus = readFlameStatus();
    int filteredReading = burner.lastFlameReading;
    
    if (rawReading > maxFlameReading) maxFlameReading = rawReading;
    if (flameStatus) flameDetections++;
    
    Serial.print(elapsed); Serial.print("s | ");
    Serial.print(rawReading); Serial.print(" | ");
    Serial.print(filteredReading); Serial.print(" | ");
    Serial.print(rawReading > FLAME_DETECTION_THRESHOLD ? "YES" : "no");
    if (flameStatus) Serial.print(" üî•");
    Serial.println();
    
    delay(1000);
  }
  
  // Step 5: Results Analysis
  Serial.println("\n*** STEP 5: DIAGNOSTIC RESULTS ***");
  Serial.println("====================================");
  
  Serial.print("Baseline average: "); Serial.println(baselineAvg);
  Serial.print("Max flame reading: "); Serial.println(maxFlameReading);
  Serial.print("Signal increase: "); Serial.println(maxFlameReading - baselineAvg);
  Serial.print("Flame detections: "); Serial.println(flameDetections);
  Serial.print("Current threshold: "); Serial.println(FLAME_DETECTION_THRESHOLD);
  
  Serial.println("\n--- ASSESSMENT ---");
  
  if (maxFlameReading - baselineAvg < 20) {
    Serial.println("‚ùå POOR: Very weak flame signal");
    Serial.println("SOLUTIONS:");
    Serial.println("1. Hold flame closer to flame rod probe");
    Serial.println("2. Check 1MŒ© resistor value (must be 1 megohm)");
    Serial.println("3. Verify flame rod is metallic and conductive");
    Serial.println("4. Ensure ESP GND connected to burner/lighter chassis");
  } else if (maxFlameReading - baselineAvg < 50) {
    Serial.println("‚ö†Ô∏è  MARGINAL: Weak but detectable signal");
    Serial.println("IMPROVEMENTS:");
    Serial.println("1. Position flame rod closer to flame");
    Serial.println("2. Ensure good ground connection");
    Serial.println("3. Consider lowering threshold to " + String(baselineAvg + 15));
  } else {
    Serial.println("‚úÖ EXCELLENT: Strong flame signal detected!");
    Serial.println("Your flame sensor is working properly!");
  }
  
  if (flameDetections > 10) {
    Serial.println("‚úÖ GOOD: Consistent flame detection during test");
  } else if (flameDetections > 0) {
    Serial.println("‚ö†Ô∏è  INTERMITTENT: Some flame detection - improve signal");
  } else {
    Serial.println("‚ùå FAILED: No stable flame detection");
  }
  
  Serial.println("\n--- NEXT STEPS ---");
  if (maxFlameReading - baselineAvg >= 20 && flameDetections > 5) {
    Serial.println("üéâ SUCCESS! Your flame sensor is working!");
    Serial.println("You can now proceed with your burner testing.");
    Serial.println("Try command 'ignite' to test full system.");
  } else {
    Serial.println("üîß MORE WORK NEEDED:");
    Serial.println("1. Fix wiring issues identified above");
    Serial.println("2. Re-run this diagnostic: 'flame_diagnostic'");
    Serial.println("3. Try 'wiring_test' for detailed connection check");
  }
  
  Serial.println("\n=== DIAGNOSTIC COMPLETE ===");
}
