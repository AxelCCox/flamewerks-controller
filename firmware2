/*
 * FlameWerks Remote Burner Control System - SINGLE RELAY TEST VERSION
 * ESP8266 Thing Dev Board - Auburn I-31-2 Igniter Compatible
 * 
 * WARNING: TESTING CONFIGURATION - SINGLE RELAY ONLY
 * This version uses only 1 relay for PILOT VALVE control
 * Main valve functionality is DISABLED for testing
 * 
 * Current Hardware Configuration (TESTING):
 * GPIO 2  -> Pilot Valve Relay (via PC817 optocoupler) [ACTIVE]
 * GPIO 4  -> Beefcake Relay -> 12V Glow Plug Control [ACTIVE]
 * GPIO 5  -> Flame Rod Output (AC voltage to flame rod probe) [ACTIVE]
 * A0      -> Flame Rod Input (via 1MΩ resistor - flame rectification) [ACTIVE]
 * 
 *  STANDARD PRODUCTION CONFIGURATION (when you get 2nd relay):
 *  GPIO 2  -> Pilot Valve Relay (via PC817 optocoupler)
 *  GPIO 4  -> Main Valve Relay (via PC817 optocoupler) 
 *  GPIO 5  -> Igniter Control (Auburn I-31-2)
 *  A0      -> Flame Sensor (Auburn I-31-2 + 1MΩ resistor)
 *  
 *  Standard Operation:
 *  1. PILOT_IGNITING: Open pilot valve + igniter spark
 *  2. PILOT_ESTABLISHED: Pilot flame detected, stabilize 2 seconds
 *  3. MAIN_ON: Open main valve for full operation
 *  
 *  Testing Operation (Current):
 *  1. PILOT_IGNITING: Open pilot valve + igniter spark
 *  2. PILOT_ON: Pilot flame detected, stay in pilot mode
 *  3. Main valve commands are logged but not executed
 
 * 
 * Safety Features:
 * - 5-second ignition timeout with automatic shutoff
 * - Flame loss detection with immediate emergency closure
 * - 3-attempt retry logic with 3-second cooldown
 * - Fault state requiring manual reset
 * - Electrical isolation via PC817 optocouplers
 */

#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <ESP8266mDNS.h>
#include <WiFiClient.h>

// --- Pin Definitions (ESP8266 Thing Dev Board) ---
#define PILOT_RELAY_PIN  2    // GPIO2 -> PC817 -> Pilot Valve Relay [ACTIVE]
#define MAIN_RELAY_PIN   4    // GPIO4 -> Relay/MOSFET -> 12V Glow Plug Control [ACTIVE]
#define FLAME_ROD_OUT_PIN 5   // GPIO5 -> Flame Rod AC Output [ACTIVE]
#define IGNITER_PIN      5    // GPIO5 -> Igniter/Flame Rod Output [ACTIVE] (alias)
#define FLAME_SENSE_PIN  A0   // A0 -> Flame Rod Input via 1MΩ (rectification) [ACTIVE]

// --- Configuration ---
const char* ssid = "Axels iphone";        // Your iPhone hotspot
const char* password = "password";        // Your WiFi password
const char* hostname = "flamewerks-burner";

// --- Burner State Machine (MODIFIED FOR SINGLE RELAY TESTING) ---
enum BurnerState {
  OFF,                // All systems off, safe state
  PILOT_IGNITING,     // Opening pilot valve + igniter spark
  PILOT_ON,           // Pilot flame confirmed and stable (TESTING MODE)
  // PILOT_ESTABLISHED,  // (Standard mode - disabled for testing)
  // MAIN_ON,           // (Standard mode - disabled for testing)
  FLAMEOUT,          // Flame lost, cooldown period
  FAULT              // System fault, manual reset required
};

// --- Burner Control Structure ---
struct BurnerController {
  int id;
  BurnerState state;
  unsigned long stateStartTime;
  int retryAttempt;
  bool flameDetected;
  bool igniterActive;
  bool pilotValveOpen;
  bool mainValveOpen;
  int lastFlameReading;
};

// Initialize single burner (expandable to multi-burner array)
BurnerController burner = {1, OFF, 0, 0, false, false, false, false, 0};

// --- Enhanced Safety Parameters ---
const unsigned long PILOT_IGNITION_TIME_MS = 5000;   // 5 seconds for pilot ignition
const unsigned long PILOT_STABILIZE_TIME_MS = 2000;  // 2 seconds to stabilize pilot
const unsigned long FLAME_CHECK_INTERVAL_MS = 100;   // Check flame every 100ms
const unsigned long FLAME_LOSS_TIMEOUT_MS = 500;     // 500ms to detect flame loss
const unsigned long COOLDOWN_PERIOD_MS = 3000;       // 3 second cooldown between attempts
const int MAX_IGNITION_ATTEMPTS = 3;                 // Maximum retry attempts
const int FLAME_DETECTION_THRESHOLD = 80;            // Lower threshold for flame rod (adjust based on testing)
const int FLAME_HYSTERESIS = 10;                     // Prevent flickering around threshold

// --- Web Server ---
ESP8266WebServer server(80);

// --- Hardware Control Functions ---
void setPilotValve(bool state) {
  digitalWrite(PILOT_RELAY_PIN, state ? HIGH : LOW);
  burner.pilotValveOpen = state;
  Serial.print("Pilot valve: ");
  Serial.println(state ? "OPEN" : "CLOSED");
}

void setMainValve(bool state) {
  // WARNING: TESTING MODE: Main valve relay not connected
  Serial.print("Main valve (SIMULATED): ");
  Serial.println(state ? "OPEN" : "CLOSED");
  Serial.println("   --> No hardware connected - command logged only");
  
  burner.mainValveOpen = state;  // Track state for web UI
  
  // digitalWrite(MAIN_RELAY_PIN, state ? HIGH : LOW);  // Disabled - no hardware
}

// Glow plug control function (using pin 4)
void setGlowPlug(bool state) {
  digitalWrite(MAIN_RELAY_PIN, state ? HIGH : LOW);  // Pin 4 controls glow plug circuit
  Serial.print("Glow plug (Pin 4): ");
  Serial.println(state ? "ON (3.3V signal -> 12V glow plug)" : "OFF (0V signal -> glow plug off)");
  Serial.println("   NOTE: Pin 4 outputs 3.3V to control relay/MOSFET that switches 12V to glow plug");
}

void setFlameRodOutput(bool state) {
  digitalWrite(FLAME_ROD_OUT_PIN, state ? HIGH : LOW);
  Serial.print("Flame rod output: ");
  Serial.println(state ? "ACTIVE (3.3V)" : "OFF (0V)");
}

// Enhanced flame rod output with PWM for testing different levels
void setFlameRodOutputLevel(int level) {
  // level: 0=OFF, 1=LOW(25%), 2=MEDIUM(50%), 3=HIGH(75%), 4=FULL(100%)
  int pwmValue = 0;
  String levelName = "";
  
  switch(level) {
    case 0: 
      pwmValue = 0; 
      levelName = "OFF (0V)"; 
      break;
    case 1: 
      pwmValue = 64;  // 25% of 255
      levelName = "LOW (~0.8V)"; 
      break;
    case 2: 
      pwmValue = 128; // 50% of 255
      levelName = "MEDIUM (~1.6V)"; 
      break;
    case 3: 
      pwmValue = 192; // 75% of 255
      levelName = "HIGH (~2.5V)"; 
      break;
    case 4: 
      pwmValue = 255; // 100%
      levelName = "FULL (3.3V)"; 
      break;
    default:
      pwmValue = 0;
      levelName = "INVALID - OFF";
      break;
  }
  
  analogWrite(FLAME_ROD_OUT_PIN, pwmValue);
  Serial.print("Flame rod test output: Level ");
  Serial.print(level);
  Serial.print(" - ");
  Serial.print(levelName);
  Serial.print(" (PWM: ");
  Serial.print(pwmValue);
  Serial.println(")");
}

void emergencyShutdown() {
  setFlameRodOutput(false);
  setPilotValve(false);
  setMainValve(false);
  burner.state = OFF;
  burner.retryAttempt = 0;
  Serial.println("*** EMERGENCY SHUTDOWN - ALL SYSTEMS OFF ***");
}

bool readFlameStatus() {
  int reading = analogRead(FLAME_SENSE_PIN);
  burner.lastFlameReading = reading;
  
  // Enhanced floating pin detection
  static int consecutiveMaxReadings = 0;
  static int consecutiveMinReadings = 0;
  static bool hasWarnedFloating = false;
  
  // Track consecutive max readings (indicating floating pin)
  if (reading >= 1020) {
    consecutiveMaxReadings++;
    consecutiveMinReadings = 0;
  } else if (reading <= 10) {
    consecutiveMinReadings++;
    consecutiveMaxReadings = 0;
  } else {
    consecutiveMaxReadings = 0;
    consecutiveMinReadings = 0;
  }
  
  // Warn about floating A0 pin
  if (consecutiveMaxReadings >= 3 && !hasWarnedFloating) {
    Serial.println("*** WARNING: A0 PIN FLOATING! ***");
    Serial.println("ADC reading stuck at maximum (1024) - A0 not properly connected");
    Serial.println("CHECK: 1MΩ resistor from A0 to GND, flame rod to A0 connection");
    Serial.println("This will cause false flame detection!");
    hasWarnedFloating = true;
  }
  
  // Reset warning when pin stabilizes
  if (consecutiveMinReadings >= 5 && hasWarnedFloating) {
    Serial.println("*** A0 PIN STABILIZED - Good baseline readings ***");
    hasWarnedFloating = false;
  }
  
  // Implement hysteresis to prevent flicker
  static bool lastFlameState = false;
  bool currentFlame;
  
  // Override flame detection if pin is floating
  if (reading >= 1020) {
    currentFlame = false; // Ignore floating readings as flame detection
    Serial.print("(IGNORING floating A0 reading) ");
  } else {
    if (lastFlameState) {
      // If flame was detected, require lower threshold to turn off (hysteresis)
      currentFlame = reading > (FLAME_DETECTION_THRESHOLD - FLAME_HYSTERESIS);
    } else {
      // If no flame, require higher threshold to detect flame
      currentFlame = reading > (FLAME_DETECTION_THRESHOLD + FLAME_HYSTERESIS);
    }
  }
  
  lastFlameState = currentFlame;
  
  // Debug output every 2 seconds
  static unsigned long lastDebugOutput = 0;
  if (millis() - lastDebugOutput > 2000) {
    Serial.print("Flame rod ADC: ");
    Serial.print(reading);
    if (reading >= 1020) {
      Serial.print(" (FLOATING!)");
    }
    Serial.print(" (Threshold: ");
    Serial.print(FLAME_DETECTION_THRESHOLD);
    Serial.print("), Flame: ");
    Serial.print(currentFlame ? "DETECTED" : "NONE");
    if (reading >= 1020) {
      Serial.print(" [IGNORED - FIX A0 WIRING]");
    }
    Serial.println();
    lastDebugOutput = millis();
  }
  
  return currentFlame;
}

// --- Enhanced State Machine Logic (SINGLE RELAY VERSION) ---
void updateBurnerStateMachine() {
  unsigned long currentTime = millis();
  
  // Only update state machine once per second to reduce spam
  static unsigned long lastStateMachineUpdate = 0;
  if (currentTime - lastStateMachineUpdate < 1000) {
    return; // Throttle state machine updates to once per second
  }
  lastStateMachineUpdate = currentTime;
  
  // Read flame status only when needed
  burner.flameDetected = readFlameStatus();
  
  switch (burner.state) {
    case OFF:
      // Safe state - all systems off (only set once per state change)
      static BurnerState lastState = FAULT; // Initialize to different state
      if (lastState != OFF) {
        setFlameRodOutput(false);
        setPilotValve(false);
        setMainValve(false);
        Serial.println("System in OFF state - Type 'help' for commands");
        lastState = OFF;
      }
      break;
      
    case PILOT_IGNITING:
      lastState = PILOT_IGNITING;
      // Phase 1: Open pilot valve and activate flame rod
      setPilotValve(true);
      setMainValve(false);
      setFlameRodOutput(true);  // Activate flame rod for detection
      
      if (burner.flameDetected) {
        // Pilot flame established! (Testing mode - stay in pilot)
        burner.state = PILOT_ON;  // Modified for testing
        burner.stateStartTime = currentTime;
        burner.retryAttempt = 0;  // Reset retry counter
        Serial.println("STATE: Pilot flame detected via flame rod -> PILOT_ON (TESTING MODE)");
        Serial.println("   --> In production mode, this would proceed to main valve");
      } 
      else if (currentTime - burner.stateStartTime > PILOT_IGNITION_TIME_MS) {
        // Ignition timeout
        setFlameRodOutput(false);
        setPilotValve(false);
        
        if (burner.retryAttempt < MAX_IGNITION_ATTEMPTS) {
          burner.retryAttempt++;
          burner.state = FLAMEOUT;
          burner.stateStartTime = currentTime;
          Serial.print("STATE: Pilot ignition failed, attempt ");
          Serial.print(burner.retryAttempt);
          Serial.print("/");
          Serial.println(MAX_IGNITION_ATTEMPTS);
        } else {
          burner.state = FAULT;
          burner.stateStartTime = currentTime;
          Serial.println("STATE: Maximum ignition attempts exceeded -> FAULT");
        }
      }
      break;
      
    case PILOT_ON:
      lastState = PILOT_ON;
      // Testing mode: Pilot running, main valve simulated
      setPilotValve(true);
      setMainValve(true);  // Simulated only
      setFlameRodOutput(true);  // Keep flame rod active for monitoring
      
      if (!burner.flameDetected) {
        // Pilot flame lost!
        emergencyShutdown();
        burner.state = FLAMEOUT;
        burner.stateStartTime = currentTime;
        Serial.println("STATE: Pilot flame lost (flame rod) -> EMERGENCY FLAMEOUT");
      }
      break;
      
    case FLAMEOUT:
      lastState = FLAMEOUT;
      // Cooldown period before retry
      setFlameRodOutput(false);
      setPilotValve(false);
      setMainValve(false);
      
      if (currentTime - burner.stateStartTime > COOLDOWN_PERIOD_MS) {
        if (burner.retryAttempt < MAX_IGNITION_ATTEMPTS) {
          // Attempt restart
          burner.state = PILOT_IGNITING;
          burner.stateStartTime = currentTime;
          Serial.println("STATE: Cooldown complete, retrying ignition -> PILOT_IGNITING");
        } else {
          burner.state = FAULT;
          Serial.println("STATE: Maximum retries exceeded -> FAULT");
        }
      }
      break;
      
    case FAULT:
      lastState = FAULT;
      // System fault - requires manual reset
      setFlameRodOutput(false);
      setPilotValve(false);
      setMainValve(false);
      
      // Fault state can only be cleared by manual reset command
      break;
  }
}

// --- Web Server Handlers ---
void handleRoot() {
  // Serve the web UI
  server.sendHeader("Content-Type", "text/html");
  server.send(200, "text/html", getWebUI());
}

void handleStatus() {
  // Return enhanced status as JSON
  String json = "[{";
  json += "\"id\":1,";
  json += "\"state\":\"";
  
  switch (burner.state) {
    case OFF: json += "off"; break;
    case PILOT_IGNITING: json += "igniting"; break;
    case PILOT_ON: json += "pilot-running"; break;  // Modified for testing
    case FLAMEOUT: json += "flameout"; break;
    case FAULT: json += "fault"; break;
  }
  
  json += "\",\"flame\":";
  json += burner.flameDetected ? "true" : "false";
  json += ",\"attempts\":";
  json += String(burner.retryAttempt);
  json += ",\"maxAttempts\":";
  json += String(MAX_IGNITION_ATTEMPTS);
  json += ",\"flameSensorValue\":";
  json += String(burner.lastFlameReading);
  json += ",\"igniterActive\":";
  json += burner.igniterActive ? "true" : "false";
  json += ",\"pilotOpen\":";
  json += burner.pilotValveOpen ? "true" : "false";
  json += ",\"mainOpen\":";
  json += burner.mainValveOpen ? "true" : "false";
  json += "}]";
  
  server.send(200, "application/json", json);
}

void handleControl() {
  String response = "";
  
  if (server.hasArg("cmd")) {
    String cmd = server.arg("cmd");
    
    if (cmd == "ignite" || cmd == "on") {
      if (burner.state == OFF || burner.state == FAULT) {
        burner.state = PILOT_IGNITING;
        burner.stateStartTime = millis();
        burner.retryAttempt = 0;
        response = "Ignition sequence initiated - Pilot valve opening";
        Serial.println("WEB COMMAND: Starting ignition sequence");
      } else {
        response = "Burner already active or in ignition process";
      }
    }
    else if (cmd == "stop" || cmd == "off") {
      emergencyShutdown();
      response = "Emergency shutdown executed - All systems OFF";
      Serial.println("WEB COMMAND: Emergency shutdown");
    }
    else if (cmd == "reset") {
      if (burner.state == FAULT) {
        burner.state = OFF;
        burner.retryAttempt = 0;
        response = "System reset from FAULT to OFF state";
        Serial.println("WEB COMMAND: Fault reset to OFF");
      } else {
        response = "Reset command only available in FAULT state";
      }
    }
    else {
      response = "Unknown command: " + cmd + " (use: ignite, stop, reset)";
    }
  } else {
    response = "Missing cmd parameter";
  }
  
  server.send(200, "text/plain", response);
}

void handleNotFound() {
  server.send(404, "text/plain", "File not found");
}

// --- Serial Command Interface ---
void handleSerialCommands() {
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('\n');
    cmd.trim();
    cmd.toLowerCase();
    
    if (cmd == "i" || cmd == "ignite") {
      if (burner.state == OFF || burner.state == FAULT) {
        burner.state = PILOT_IGNITING;
        burner.stateStartTime = millis();
        burner.retryAttempt = 0;
        Serial.println("SERIAL: Ignition sequence started");
      } else {
        Serial.println("SERIAL: Burner already active");
      }
    }
    else if (cmd == "s" || cmd == "stop" || cmd == "off") {
      emergencyShutdown();
      Serial.println("SERIAL: Emergency shutdown executed");
    }
    else if (cmd == "r" || cmd == "reset") {
      burner.state = OFF;
      burner.retryAttempt = 0;
      Serial.println("SERIAL: System reset to OFF");
    }
    else if (cmd == "status" || cmd == "st") {
      Serial.println("=== FLAMEWERKS BURNER STATUS ===");
      
      // Add WiFi status first
      Serial.print("WiFi Status: ");
      if (WiFi.status() == WL_CONNECTED) {
        Serial.print("CONNECTED to ");
        Serial.println(WiFi.SSID());
        Serial.print("IP Address: ");
        Serial.println(WiFi.localIP());
        Serial.print("Web UI: http://");
        Serial.println(WiFi.localIP());
      } else {
        Serial.println("DISCONNECTED");
        Serial.print("Trying to connect to: ");
        Serial.println(ssid);
      }
      Serial.println("--------------------------------");
      
      Serial.print("State: ");
      switch (burner.state) {
        case OFF: Serial.println("OFF"); break;
        case PILOT_IGNITING: Serial.println("PILOT_IGNITING"); break;
        case PILOT_ON: Serial.println("PILOT_ON (TESTING MODE)"); break;
        case FLAMEOUT: Serial.println("FLAMEOUT"); break;
        case FAULT: Serial.println("FAULT"); break;
      }
      Serial.print("Flame detected: ");
      Serial.println(burner.flameDetected ? "YES" : "NO");
      Serial.print("Flame sensor ADC: ");
      Serial.println(burner.lastFlameReading);
      Serial.print("Ignition attempts: ");
      Serial.print(burner.retryAttempt);
      Serial.print("/");
      Serial.println(MAX_IGNITION_ATTEMPTS);
      Serial.print("Hardware status - Flame Rod: ");
      Serial.print(digitalRead(FLAME_ROD_OUT_PIN) ? "ACTIVE" : "OFF");
      Serial.print(", Pilot: ");
      Serial.print(burner.pilotValveOpen ? "OPEN" : "CLOSED");
      Serial.print(", Main: ");
      Serial.println(burner.mainValveOpen ? "OPEN" : "CLOSED");
      Serial.println("==============================");
    }
    else if (cmd == "help" || cmd == "h") {
      Serial.println("=== FLAMEWERKS SERIAL COMMANDS ===");
      Serial.println("i/ignite     - Start ignition sequence");
      Serial.println("s/stop       - Emergency shutdown");
      Serial.println("r/reset      - Reset system to OFF");
      Serial.println("status/st    - Show detailed status");
      Serial.println("test         - Basic flame sensor test");
      Serial.println("flame_test   - Detailed flame sensor analysis");
      Serial.println("flame_cal    - Calibrate flame sensor");
      Serial.println("flame_on     - Turn flame rod output ON");
      Serial.println("flame_off    - Turn flame rod output OFF");
      Serial.println("flame_levels - Test all flame rod output levels");
      Serial.println("flame_level <0-4> - Set specific flame rod level");
      Serial.println("flame_continuous - Continuous flame monitoring");
      Serial.println("test_no_flame    - Test with no flame (rod OFF)");
      Serial.println("test_small_flame - Test with small flame simulation");
      Serial.println("test_full_flame  - Test with full flame simulation");
      Serial.println("a0_test          - Enhanced A0 pin stability test (20 readings)");
      Serial.println("wiring_test      - Diagnose A0 pin wiring issues");
      Serial.println("glow_on      - Turn glow plug ON (pin 4)");
      Serial.println("glow_off     - Turn glow plug OFF (pin 4)");
      Serial.println("glow_test    - Test glow plug control sequence");
      Serial.println("pin_test     - Test all GPIO pin outputs");
      Serial.println("help/h       - Show this help");
      Serial.println("===================================");;
    }
    else if (cmd == "test") {
      Serial.println("=== FLAME ROD TEST ===");
      Serial.println("Testing flame rod rectification circuit...");
      for (int i = 0; i < 10; i++) {
        int reading = analogRead(FLAME_SENSE_PIN);
        Serial.print("Reading ");
        Serial.print(i + 1);
        Serial.print(": ");
        Serial.print(reading);
        Serial.print(" (Threshold: ");
        Serial.print(FLAME_DETECTION_THRESHOLD);
        Serial.print(", Detected: ");
        Serial.print(reading > FLAME_DETECTION_THRESHOLD ? "YES" : "NO");
        Serial.print(", Rod Output: ");
        Serial.print(digitalRead(FLAME_ROD_OUT_PIN) ? "ACTIVE" : "OFF");
        Serial.println(")");
        delay(500);
      }
      Serial.println("========================");
    }
    else if (cmd == "test_no_flame") {
      Serial.println("=== NO FLAME TEST ===");
      Serial.println("Testing sensor with flame rod OFF (no power)");
      setFlameRodOutput(false);  // Turn OFF flame rod power
      delay(1000);  // Let it stabilize
      
      Serial.println("Taking 10 readings with NO flame rod power...");
      int total = 0;
      for (int i = 0; i < 10; i++) {
        int reading = analogRead(FLAME_SENSE_PIN);
        total += reading;
        bool detected = reading > FLAME_DETECTION_THRESHOLD;
        
        Serial.print("Reading ");
        Serial.print(i + 1);
        Serial.print(": ADC=");
        Serial.print(reading);
        Serial.print(", Detected=");
        Serial.print(detected ? "YES" : "NO");
        Serial.print(", Rod Power=OFF");
        Serial.println();
        delay(500);
      }
      
      int average = total / 10;
      Serial.print("RESULT: Average ADC = ");
      Serial.print(average);
      Serial.print(", Should be LOW (< 30) for good baseline");
      Serial.println();
      
      if (average < 30) {
        Serial.println("GOOD: Low baseline - flame rod circuit working properly");
      } else {
        Serial.println("WARNING: High baseline - check wiring or interference");
      }
      Serial.println("======================");
    }
    else if (cmd == "test_small_flame") {
      Serial.println("=== SMALL FLAME TEST ===");
      Serial.println("Testing sensor with LOW flame rod power (simulating small flame)");
      
      // Use PWM to simulate small flame detection
      analogWrite(FLAME_ROD_OUT_PIN, 64);  // 25% power (low flame simulation)
      delay(1000);  // Let it stabilize
      
      Serial.println("Taking 10 readings with LOW flame rod power...");
      int total = 0;
      for (int i = 0; i < 10; i++) {
        int reading = analogRead(FLAME_SENSE_PIN);
        total += reading;
        bool detected = reading > FLAME_DETECTION_THRESHOLD;
        
        Serial.print("Reading ");
        Serial.print(i + 1);
        Serial.print(": ADC=");
        Serial.print(reading);
        Serial.print(", Detected=");
        Serial.print(detected ? "YES" : "NO");
        Serial.print(", Rod Power=LOW(25%)");
        Serial.println();
        delay(500);
      }
      
      int average = total / 10;
      Serial.print("RESULT: Average ADC = ");
      Serial.print(average);
      Serial.print(", Threshold = ");
      Serial.print(FLAME_DETECTION_THRESHOLD);
      Serial.println();
      
      if (average > FLAME_DETECTION_THRESHOLD) {
        Serial.println("GOOD: Small flame detected - sensor responding to low power");
      } else {
        Serial.println("INFO: Small flame not detected - may need higher power or different threshold");
      }
      
      setFlameRodOutput(false);  // Turn off after test
      Serial.println("=========================");
    }
    else if (cmd == "test_full_flame") {
      Serial.println("=== FULL FLAME TEST ===");
      Serial.println("Testing sensor with FULL flame rod power (simulating strong flame)");
      setFlameRodOutput(true);  // Turn ON full flame rod power (3.3V)
      delay(1000);  // Let it stabilize
      
      Serial.println("Taking 10 readings with FULL flame rod power...");
      int total = 0;
      for (int i = 0; i < 10; i++) {
        int reading = analogRead(FLAME_SENSE_PIN);
        total += reading;
        bool detected = reading > FLAME_DETECTION_THRESHOLD;
        
        Serial.print("Reading ");
        Serial.print(i + 1);
        Serial.print(": ADC=");
        Serial.print(reading);
        Serial.print(", Detected=");
        Serial.print(detected ? "YES" : "NO");
        Serial.print(", Rod Power=FULL(3.3V)");
        Serial.println();
        delay(500);
      }
      
      int average = total / 10;
      Serial.print("RESULT: Average ADC = ");
      Serial.print(average);
      Serial.print(", Threshold = ");
      Serial.print(FLAME_DETECTION_THRESHOLD);
      Serial.println();
      
      if (average > FLAME_DETECTION_THRESHOLD + 50) {
        Serial.println("EXCELLENT: Strong flame signal - sensor working perfectly");
      } else if (average > FLAME_DETECTION_THRESHOLD) {
        Serial.println("GOOD: Flame detected - sensor working");
      } else {
        Serial.println("PROBLEM: No flame detected with full power - check circuit");
      }
      
      setFlameRodOutput(false);  // Turn off after test
      Serial.println("==========================");
    }
    else if (cmd == "a0_test") {
      Serial.println("=== A0 PIN DIAGNOSTIC TEST ===");
      Serial.println("This will take 20 readings over 2 seconds to diagnose A0 wiring issues");
      Serial.println();
      
      int maxReading = 0;
      int minReading = 1024;
      int floatingCount = 0;
      int normalCount = 0;
      int totalReading = 0;
      
      for (int i = 0; i < 20; i++) {
        int reading = analogRead(FLAME_SENSE_PIN);
        totalReading += reading;
        
        if (reading > maxReading) maxReading = reading;
        if (reading < minReading) minReading = reading;
        
        if (reading >= 1020) {
          floatingCount++;
          Serial.print("Reading ");
          Serial.print(i+1);
          Serial.print(": ");
          Serial.print(reading);
          Serial.println(" <- FLOATING/DISCONNECTED");
        } else {
          normalCount++;
          Serial.print("Reading ");
          Serial.print(i+1);
          Serial.print(": ");
          Serial.println(reading);
        }
        
        delay(100);
      }
      
      Serial.println();
      Serial.println("=== A0 DIAGNOSTIC RESULTS ===");
      Serial.print("Max reading: "); Serial.println(maxReading);
      Serial.print("Min reading: "); Serial.println(minReading);
      Serial.print("Average: "); Serial.println(totalReading / 20);
      Serial.print("Floating readings: "); Serial.print(floatingCount); Serial.println("/20");
      Serial.print("Normal readings: "); Serial.print(normalCount); Serial.println("/20");
      
      Serial.println();
      if (floatingCount > 10) {
        Serial.println("*** PROBLEM: A0 PIN IS FLOATING! ***");
        Serial.println("DIAGNOSIS: A0 is not properly connected to ground through 1MΩ resistor");
        Serial.println("SOLUTION:");
        Serial.println("1. Connect 1MΩ resistor between A0 and GND pins on ESP8266");
        Serial.println("2. Connect flame rod wire to A0 pin");
        Serial.println("3. Verify GND connection is solid");
        Serial.println("4. Check for loose wires or bad solder joints");
      } else if (floatingCount > 0) {
        Serial.println("*** WARNING: Intermittent A0 connection ***");
        Serial.println("Some floating readings detected - check connections");
      } else if (maxReading < 50 && minReading < 10) {
        Serial.println("*** GOOD: A0 pin stable and grounded ***");
        Serial.println("A0 wiring appears correct for flame detection");
      } else {
        Serial.println("*** INFO: A0 readings look normal ***");
        Serial.println("Check flame rod positioning and output levels");
      }
      Serial.println();
    }
    else if (cmd == "wiring_test") {
      Serial.println("=== A0 PIN WIRING DIAGNOSTIC ===");
      Serial.println("This will help diagnose flame sensor wiring issues");
      Serial.println("Your symptoms: ADC jumping between 0, 1024, and unstable readings");
      Serial.println("This indicates A0 pin floating or poor connections");
      
      // Test A0 with everything OFF
      setFlameRodOutput(false);
      delay(500);
      
      Serial.println("\nStep 1: Multiple A0 readings with flame rod OFF...");
      Serial.println("Taking 10 readings to check for instability:");
      int readings[10];
      int minVal = 1024, maxVal = 0;
      
      for (int i = 0; i < 10; i++) {
        readings[i] = analogRead(FLAME_SENSE_PIN);
        if (readings[i] < minVal) minVal = readings[i];
        if (readings[i] > maxVal) maxVal = readings[i];
        Serial.print("  Reading ");
        Serial.print(i + 1);
        Serial.print(": ");
        Serial.print(readings[i]);
        if (readings[i] >= 1020) {
          Serial.print(" (MAX - floating!)");
        } else if (readings[i] <= 5) {
          Serial.print(" (grounded)");
        }
        Serial.println();
        delay(200);
      }
      
      int range = maxVal - minVal;
      Serial.print("\nRange: ");
      Serial.print(minVal);
      Serial.print(" to ");
      Serial.print(maxVal);
      Serial.print(" (span: ");
      Serial.print(range);
      Serial.println(")");
      
      if (range > 100) {
        Serial.println("** PROBLEM: Highly unstable readings - A0 pin is FLOATING **");
        Serial.println("   CRITICAL: A0 pin not properly connected!");
        Serial.println("   FIXES:");
        Serial.println("   1. Check A0 wire is firmly inserted into breadboard/connector");
        Serial.println("   2. Add 1MΩ resistor from A0 to GND if missing");
        Serial.println("   3. Check for loose connections at A0 pin");
        Serial.println("   4. Verify continuity from A0 pin to your circuit");
      } else if (maxVal >= 1020) {
        Serial.println("** PROBLEM: A0 reading maximum (3.3V) **");
        Serial.println("   Possible causes:");
        Serial.println("   * A0 not connected to circuit (floating)");
        Serial.println("   * A0 shorted to 3.3V rail");
        Serial.println("   * Missing pull-down resistor (1MΩ to GND)");
      } else if (maxVal <= 10) {
        Serial.println("** GOOD: A0 properly grounded via resistor **");
      }
      
      Serial.println("\nStep 2: Testing with flame rod ON...");
      setFlameRodOutput(true);
      delay(1000);
      
      Serial.println("Taking 5 readings with flame rod power ON:");
      for (int i = 0; i < 5; i++) {
        int reading = analogRead(FLAME_SENSE_PIN);
        Serial.print("  With power ");
        Serial.print(i + 1);
        Serial.print(": ");
        Serial.print(reading);
        if (reading >= 1020) {
          Serial.print(" (still floating!)");
        }
        Serial.println();
        delay(200);
      }
      
      setFlameRodOutput(false);
      
      Serial.println("\n=== HARDWARE DIAGNOSIS ===");
      Serial.println("Based on your unstable 0/1024 readings:");
      Serial.println();
      Serial.println("MOST LIKELY PROBLEM: A0 pin is FLOATING (not connected)");
      Serial.println();
      Serial.println("IMMEDIATE FIXES TO TRY:");
      Serial.println("1. **CHECK A0 CONNECTION**");
      Serial.println("   - Verify wire is firmly connected to A0 pin");
      Serial.println("   - Use multimeter to test continuity from A0 pin to your circuit");
      Serial.println();
      Serial.println("2. **ADD PULL-DOWN RESISTOR**");
      Serial.println("   - Connect 1MΩ resistor from A0 to GND");
      Serial.println("   - This prevents floating and provides stable baseline");
      Serial.println();
      Serial.println("3. **VERIFY FLAME ROD CIRCUIT**");
      Serial.println("   - GPIO5 (D1) -> Flame Rod Probe");
      Serial.println("   - Flame Rod Probe -> A0 + 1MΩ resistor");
      Serial.println("   - 1MΩ resistor -> GND");
      Serial.println();
      Serial.println("Expected behavior after fixing:");
      Serial.println("- A0 should read 0-30 when flame rod OFF");
      Serial.println("- A0 should read 50-200+ when flame rod ON");
      Serial.println("- Readings should be stable, not jumping wildly");
      Serial.println("==============================");
    }
    else if (cmd == "flame_levels" || cmd == "fl") {
      testFlameRodLevels();
    }
    else if (cmd.startsWith("flame_level ")) {
      // Extract level number from command like "flame_level 2"
      String levelStr = cmd.substring(12); // Remove "flame_level "
      int level = levelStr.toInt();
      if (level >= 0 && level <= 4) {
        setFlameRodOutputLevel(level);
        
        // Show immediate reading
        delay(100); // Let output stabilize
        int reading = analogRead(FLAME_SENSE_PIN);
        Serial.print("Immediate sensor reading: ");
        Serial.print(reading);
        Serial.print(" (Detected: ");
        Serial.print(reading > FLAME_DETECTION_THRESHOLD ? "YES" : "NO");
        Serial.println(")");
      } else {
        Serial.println("Invalid level. Use 0-4: 0=OFF, 1=LOW, 2=MED, 3=HIGH, 4=FULL");
      }
    }
    else if (cmd == "flame_test" || cmd == "ft") {
      testFlameRodDetailed();
    }
    else if (cmd == "flame_cal" || cmd == "fc") {
      calibrateFlameRod();
    }
    else if (cmd == "flame_on") {
      setFlameRodOutput(true);
      Serial.println("Flame rod output turned ON (3.3V)");
    }
    else if (cmd == "flame_off") {
      setFlameRodOutput(false);
      Serial.println("Flame rod output turned OFF (0V)");
    }
    else if (cmd == "flame_test" || cmd == "ft") {
      testFlameRodDetailed();
    }
    else if (cmd == "flame_cal" || cmd == "fc") {
      calibrateFlameRod();
    }
    else if (cmd == "flame_continuous" || cmd == "fcon") {
      Serial.println("=== CONTINUOUS FLAME MONITORING ===");
      Serial.println("Press any key to stop...");
      Serial.println("Format: Reading | Voltage | Status");
      Serial.println("===================================");
      
      while (!Serial.available()) {
        int reading = analogRead(FLAME_SENSE_PIN);
        float voltage = (reading * 3.3) / 1024.0;
        bool detected = reading > FLAME_DETECTION_THRESHOLD;
        
        Serial.print(reading);
        Serial.print(" | ");
        Serial.print(voltage, 2);
        Serial.print("V | ");
        Serial.println(detected ? "FLAME" : "NO FLAME");
        delay(500);
      }
      // Clear the serial buffer
      while (Serial.available()) Serial.read();
      Serial.println("Continuous monitoring stopped.");
    }
    else if (cmd == "glow_on") {
      Serial.println("=== GLOW PLUG ON ===");
      setGlowPlug(true);
      Serial.println("Pin 4 now outputs 3.3V to control your 12V glow plug circuit");
      Serial.println("Check: 1) Pin 4 = 3.3V, 2) 12V supply to glow plug via relay/MOSFET");
      Serial.println();
      Serial.println("TROUBLESHOOTING CHECKLIST:");
      Serial.println("□ Pin 4 measures 3.3V with multimeter");
      Serial.println("□ Beefcake relay clicks/energizes when pin goes HIGH");
      Serial.println("□ 12V power supply connected to relay input");
      Serial.println("□ Glow plug connected to relay output contacts");
      Serial.println("□ Glow plug gets 12V when relay is energized");
      Serial.println("□ Glow plug starts heating within 30 seconds");
    }
    else if (cmd == "glow_off") {
      Serial.println("=== GLOW PLUG OFF ===");
      setGlowPlug(false);
      Serial.println("Pin 4 now outputs 0V - glow plug should be OFF");
      Serial.println("Check: 1) Pin 4 = 0V, 2) No 12V to glow plug");
      Serial.println("□ Pin 4 measures 0V with multimeter");
      Serial.println("□ Beefcake relay de-energizes (no click/power)");
      Serial.println("□ No 12V to glow plug");
    }
    else if (cmd == "glow_test") {
      Serial.println("=== GLOW PLUG TEST SEQUENCE ===");
      Serial.println("This will test the glow plug control circuit");
      Serial.println();
      
      Serial.println("Step 1: Turning glow plug OFF...");
      setGlowPlug(false);
      Serial.println("Measure: Pin 4 should be 0V, glow plug should be OFF");
      Serial.println("Press any key to continue...");
      while (!Serial.available()) delay(100);
      while (Serial.available()) Serial.read();
      
      Serial.println();
      Serial.println("Step 2: Turning glow plug ON...");
      setGlowPlug(true);
      Serial.println("Measure: Pin 4 should be 3.3V, glow plug should get 12V");
      Serial.println("Check if glow plug is heating up!");
      Serial.println("Press any key to continue...");
      while (!Serial.available()) delay(100);
      while (Serial.available()) Serial.read();
      
      Serial.println();
      Serial.println("Step 3: 5-second ON test...");
      Serial.println("Glow plug will stay ON for 5 seconds");
      for (int i = 5; i > 0; i--) {
        Serial.print("Glow plug ON - ");
        Serial.print(i);
        Serial.println(" seconds remaining");
        delay(1000);
      }
      
      Serial.println();
      Serial.println("Step 4: Turning glow plug OFF...");
      setGlowPlug(false);
      Serial.println("Glow plug test complete!");
      Serial.println();
      Serial.println("=== EXPECTED RESULTS ===");
      Serial.println("- Pin 4: 0V=OFF, 3.3V=ON");
      Serial.println("- Glow plug: Should get 12V when ON");
      Serial.println("- Glow plug should heat up when 12V applied");
      Serial.println("- If no heating: check relay/MOSFET circuit");
      Serial.println("========================");
    }
    else if (cmd == "pin_test") {
      Serial.println("=== GPIO PIN TEST ===");
      Serial.println("Testing all output pins individually...");
      Serial.println();
      
      Serial.println("Testing Pin 2 (Pilot Valve):");
      Serial.println("  Setting LOW...");
      digitalWrite(PILOT_RELAY_PIN, LOW);
      delay(1000);
      Serial.print("  Pin 2 state: ");
      Serial.println(digitalRead(PILOT_RELAY_PIN) ? "HIGH" : "LOW");
      
      Serial.println("  Setting HIGH...");
      digitalWrite(PILOT_RELAY_PIN, HIGH);
      delay(1000);
      Serial.print("  Pin 2 state: ");
      Serial.println(digitalRead(PILOT_RELAY_PIN) ? "HIGH" : "LOW");
      digitalWrite(PILOT_RELAY_PIN, LOW); // Return to OFF
      
      Serial.println();
      Serial.println("Testing Pin 4 (Glow Plug):");
      Serial.println("  Setting LOW...");
      digitalWrite(MAIN_RELAY_PIN, LOW);
      delay(1000);
      Serial.print("  Pin 4 state: ");
      Serial.println(digitalRead(MAIN_RELAY_PIN) ? "HIGH" : "LOW");
      Serial.println("  ** Check multimeter: Pin 4 should be 0V **");
      
      Serial.println("  Setting HIGH...");
      digitalWrite(MAIN_RELAY_PIN, HIGH);
      delay(2000);
      Serial.print("  Pin 4 state: ");
      Serial.println(digitalRead(MAIN_RELAY_PIN) ? "HIGH" : "LOW");
      Serial.println("  ** Check multimeter: Pin 4 should be 3.3V **");
      Serial.println("  ** Check beefcake relay: Should click and energize **");
      digitalWrite(MAIN_RELAY_PIN, LOW); // Return to OFF
      
      Serial.println();
      Serial.println("Testing Pin 5 (Flame Rod):");
      Serial.println("  Setting LOW...");
      digitalWrite(FLAME_ROD_OUT_PIN, LOW);
      delay(1000);
      Serial.print("  Pin 5 state: ");
      Serial.println(digitalRead(FLAME_ROD_OUT_PIN) ? "HIGH" : "LOW");
      
      Serial.println("  Setting HIGH...");
      digitalWrite(FLAME_ROD_OUT_PIN, HIGH);
      delay(1000);
      Serial.print("  Pin 5 state: ");
      Serial.println(digitalRead(FLAME_ROD_OUT_PIN) ? "HIGH" : "LOW");
      digitalWrite(FLAME_ROD_OUT_PIN, LOW); // Return to OFF
      
      Serial.println();
      Serial.println("=== PIN TEST COMPLETE ===");
      Serial.println("If Pin 4 shows correct voltages but glow plug doesn't work:");
      Serial.println("1. Check beefcake relay wiring to Pin 4");
      Serial.println("2. Check 12V power supply to relay");
      Serial.println("3. Check glow plug connections through relay contacts");
      Serial.println("4. Test glow plug directly with 12V (bypass relay)");
      Serial.println("========================");
    }
    else if (cmd.length() > 0) {
      Serial.println("Unknown command. Type 'help' for available commands.");
    }
  }
}

// --- Web UI HTML (embedded) - Moved to PROGMEM to save RAM ---
const char PROGMEM webUI[] = R"rawliteral(
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>FlameWerks Burner Control</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 1em; background: #f5f5f5; }
    .container { max-width: 800px; margin: 0 auto; }
    h1 { text-align: center; color: #333; }
    .status-panel { background: white; padding: 1em; border-radius: 8px; margin: 1em 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .burner-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1em; margin: 1em 0; }
    .burner-card { background: white; padding: 1em; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .burner-status { font-size: 1.2em; font-weight: bold; margin: 0.5em 0; }
    .status-off { color: #d32f2f; }
    .status-igniting { color: #ff9800; animation: blink 1s infinite; }
    .status-on { color: #388e3c; }
    .status-fault { color: #d32f2f; background: #ffebee; padding: 0.2em; }
    @keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0.3; } }
    .controls { display: flex; gap: 0.5em; flex-wrap: wrap; margin: 1em 0; }
    .btn { padding: 0.7em 1.2em; border: none; border-radius: 4px; cursor: pointer; font-size: 1em; transition: background 0.2s; }
    .btn-primary { background: #1976d2; color: white; }
    .btn-primary:hover { background: #1565c0; }
    .btn-danger { background: #d32f2f; color: white; }
    .btn-danger:hover { background: #c62828; }
    .btn-secondary { background: #757575; color: white; }
    .btn-secondary:hover { background: #616161; }
    .emergency { background: #ffcdd2; border: 2px solid #d32f2f; padding: 1em; border-radius: 8px; margin: 1em 0; text-align: center; }
    .flame-indicator { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-left: 0.5em; }
    .flame-yes { background: #4caf50; }
    .flame-no { background: #f44336; }
  </style>
</head>
<body>
  <div class="container">
    <h1>FlameWerks Burner Control</h1>
    <div class="emergency">
      <button class="btn btn-danger" onclick="emergencyStop()">EMERGENCY STOP</button>
      <p>Immediately shuts off all valves and igniter</p>
    </div>
    <div class="status-panel">
      <h3>System Status</h3>
      <div id="systemStatus">Loading...</div>
    </div>
    <div class="burner-grid">
      <div class="burner-card">
        <h3>Burner 1</h3>
        <div id="burner1Status" class="burner-status">Loading...</div>
        <div id="burner1Flame">Flame: <span class="flame-indicator flame-no"></span></div>
        <div id="burner1Retries">Retries: 0/3</div>
        <div class="controls">
          <button class="btn btn-primary" onclick="startIgnition()">IGNITE</button>
          <button class="btn btn-danger" onclick="stopBurner()">STOP</button>
          <button class="btn btn-secondary" onclick="resetBurner()">RESET</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    setInterval(updateStatus, 2000);
    updateStatus();

    async function updateStatus() {
      try {
        const response = await fetch('/status');
        const burners = await response.json();
        const burner = burners[0];
        
        const statusEl = document.getElementById('burner1Status');
        const flameEl = document.getElementById('burner1Flame');
        const retriesEl = document.getElementById('burner1Retries');
        
        let statusClass = '';
        let statusText = '';
        switch(burner.state) {
          case 'off': statusClass = 'status-off'; statusText = 'OFF'; break;
          case 'igniting': statusClass = 'status-igniting'; statusText = 'IGNITING PILOT...'; break;
          case 'pilot-running': statusClass = 'status-on'; statusText = 'PILOT RUNNING (TEST)'; break;
          case 'flameout': statusClass = 'status-fault'; statusText = 'FLAMEOUT'; break;
          case 'fault': statusClass = 'status-fault'; statusText = 'FAULT - RESET REQUIRED'; break;
          default: statusClass = 'status-off'; statusText = 'UNKNOWN'; break;
        }
        
        statusEl.className = 'burner-status ' + statusClass;
        statusEl.textContent = statusText;
        
        const flameIndicator = flameEl.querySelector('.flame-indicator');
        flameIndicator.className = 'flame-indicator ' + (burner.flame ? 'flame-yes' : 'flame-no');
        flameEl.innerHTML = 'Flame: <span class="flame-indicator ' + (burner.flame ? 'flame-yes' : 'flame-no') + '"></span> ' + (burner.flame ? 'DETECTED' : 'NONE') + ' (ADC: ' + (burner.flameSensorValue || 'N/A') + ')';
        
        retriesEl.textContent = 'Attempts: ' + burner.attempts + '/' + burner.maxAttempts;
        
        document.getElementById('systemStatus').textContent = 
          'Burner 1: ' + statusText + ' | Flame: ' + (burner.flame ? 'Detected' : 'None') + ' | IP: ' + location.hostname;
          
      } catch (error) {
        console.error('Status update failed:', error);
        document.getElementById('systemStatus').textContent = 'Connection Error - Check firmware';
      }
    }

    async function sendCommand(cmd) {
      try {
        const response = await fetch('/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: 'cmd=' + cmd
        });
        const result = await response.text();
        console.log('Command result:', result);
        document.getElementById('systemStatus').textContent = result;
        setTimeout(updateStatus, 500);
      } catch (error) {
        console.error('Command failed:', error);
        alert('Command failed - check ESP8266 connection');
      }
    }

    function startIgnition() { 
      if (confirm('Start ignition sequence?')) {
        sendCommand('ignite'); 
      }
    }
    function stopBurner() { 
      if (confirm('Emergency shutdown?')) {
        sendCommand('stop'); 
      }
    }
    function resetBurner() { 
      if (confirm('Reset system from FAULT state?')) {
        sendCommand('reset'); 
      }
    }
    function emergencyStop() { 
      if (confirm('EMERGENCY STOP will immediately shut off all systems!')) {
        sendCommand('stop'); 
      }
    }
  </script>
</body>
</html>
)rawliteral";

String getWebUI() {
  return FPSTR(webUI);
}

// --- Setup Function ---
void setup() {
  // Initialize serial communication
  Serial.begin(115200);
  Serial.println("\n=== FlameWerks Remote Burner Control System ===");
  Serial.println("ESP8266 Thing Dev - Auburn I-31-2 Compatible");
  
  // Initialize GPIO pins
  pinMode(PILOT_RELAY_PIN, OUTPUT);
  pinMode(MAIN_RELAY_PIN, OUTPUT);  // Pin 4 - Now enabled for glow plug control
  pinMode(IGNITER_PIN, OUTPUT);
  
  // Ensure all outputs start OFF
  setPilotValve(false);
  setMainValve(false);
  setFlameRodOutput(false);
  setGlowPlug(false);  // Initialize glow plug to OFF
  
  // Initialize burner controller
  burner.state = OFF;
  burner.stateStartTime = millis();
  burner.retryAttempt = 0;
  burner.flameDetected = false;
  burner.igniterActive = false;
  burner.pilotValveOpen = false;
  burner.mainValveOpen = false;
  
  Serial.println("Hardware initialized - Single relay testing mode");
  Serial.println("WARNING: PILOT VALVE ONLY - Main valve simulated");
  Serial.println("   Connect 2nd relay to GPIO4 for full operation");
  
  // Connect to WiFi
  WiFi.mode(WIFI_STA);
  WiFi.hostname(hostname);
  WiFi.begin(ssid, password);
  
  Serial.print("Connecting to WiFi");
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi connected successfully!");
    Serial.print("IP address: ");
    Serial.println(WiFi.localIP());
    Serial.print("Hostname: ");
    Serial.println(hostname);
    
    // Start mDNS responder
    if (MDNS.begin(hostname)) {
      Serial.println("mDNS responder started");
      Serial.print("Access via: http://");
      Serial.print(hostname);
      Serial.println(".local/");
    }
  } else {
    Serial.println("\nWiFi connection failed!");
    Serial.println("System will continue in offline mode");
  }
  
  // Configure web server routes
  server.on("/", HTTP_GET, handleRoot);
  server.on("/status", HTTP_GET, handleStatus);
  server.on("/control", HTTP_POST, handleControl);
  server.onNotFound(handleNotFound);
  
  // Start web server
  server.begin();
  Serial.println("Web server started on port 80");
  
  Serial.println("\n=== System Ready ===");
  Serial.println("Commands: i=ignite, e=stop, r=reset, s=status, help");
  Serial.println("Web UI: http://" + WiFi.localIP().toString() + "/");
  Serial.println("========================\n");
}

// --- Main Loop ---
void loop() {
  // Handle web server requests
  server.handleClient();
  
  // Handle mDNS
  MDNS.update();
  
  // Handle serial commands
  handleSerialCommands();
  
  // Update burner state machine
  updateBurnerStateMachine();
  
  // Small delay to prevent excessive CPU usage
  delay(50);
}

// --- Flame Rod Testing Functions ---
void testFlameRodDetailed() {
  Serial.println("\n=== DETAILED FLAME ROD TEST ===");
  Serial.println("Testing flame rectification circuit...");
  Serial.println("Format: Sample | ADC | Status | Output");
  Serial.println("=====================================");
  
  int total = 0;
  int minVal = 1024;
  int maxVal = 0;
  int flameCount = 0;
  
  for (int i = 0; i < 20; i++) {
    int reading = analogRead(FLAME_SENSE_PIN);
    bool detected = reading > FLAME_DETECTION_THRESHOLD;
    bool rodActive = digitalRead(FLAME_ROD_OUT_PIN);
    
    total += reading;
    if (reading < minVal) minVal = reading;
    if (reading > maxVal) maxVal = reading;
    if (detected) flameCount++;
    
    Serial.print("  ");
    Serial.print(i + 1);
    Serial.print("   | ");
    Serial.print(reading);
    if (reading < 100) Serial.print(" ");
    if (reading < 10) Serial.print(" ");
    Serial.print(" | ");
    Serial.print(detected ? "FLAME" : "none ");
    Serial.print(" | ");
    Serial.println(rodActive ? "3.3V" : "0V");
    
    delay(500);
  }
  
  int average = total / 20;
  
  Serial.println("\n--- FLAME ROD ANALYSIS ---");
  Serial.print("Average: ");
  Serial.print(average);
  Serial.print(" | Range: ");
  Serial.print(minVal);
  Serial.print("-");
  Serial.print(maxVal);
  Serial.print(" | Span: ");
  Serial.println(maxVal - minVal);
  Serial.print("Threshold: ");
  Serial.print(FLAME_DETECTION_THRESHOLD);
  Serial.print(" | Detection rate: ");
  Serial.print(flameCount);
  Serial.print("/20 (");
  Serial.print((flameCount * 100) / 20);
  Serial.println("%)");
  
  Serial.println("\n--- CIRCUIT ASSESSMENT ---");
  if (maxVal - minVal < 30) {
    Serial.println("WARNING: Very low variation - check flame rod wiring");
    Serial.println("   - Verify 1MΩ resistor connection");
    Serial.println("   - Check flame rod probe contact");
  } else if (maxVal - minVal > 100) {
    Serial.println("GOOD: Good signal variation - flame rod working");
  } else {
    Serial.println("INFO: Moderate variation - acceptable operation");
  }
  
  if (average < 30) {
    Serial.println("INFO: Low baseline - good for flame detection");
  } else if (average > 100) {
    Serial.println("WARNING: High baseline - may need threshold adjustment");
  }
  
  Serial.println("===============================");
}

void calibrateFlameRod() {
  Serial.println("\n=== FLAME ROD CALIBRATION ===");
  Serial.println("This will determine optimal flame detection threshold");
  
  // Step 1: No flame reading
  Serial.println("\nSTEP 1: NO FLAME BASELINE");
  Serial.println("Turn flame rod ON but ensure no flame present...");
  setFlameRodOutput(true);
  delay(2000);
  
  Serial.println("Taking baseline readings (no flame)...");
  int noFlameTotal = 0;
  for (int i = 0; i < 10; i++) {
    int reading = analogRead(FLAME_SENSE_PIN);
    noFlameTotal += reading;
    Serial.print("No flame ");
    Serial.print(i + 1);
    Serial.print(": ");
    Serial.println(reading);
    delay(300);
  }
  int noFlameAverage = noFlameTotal / 10;
  
  Serial.print("GOOD: No flame average: ");
  Serial.println(noFlameAverage);
  
  // Step 2: With flame reading
  Serial.println("\nSTEP 2: FLAME DETECTION");
  Serial.println("Light flame near flame rod probe...");
  Serial.println("Press any key when flame is stable...");
  
  while (!Serial.available()) {
    int reading = analogRead(FLAME_SENSE_PIN);
    Serial.print("Current reading: ");
    Serial.print(reading);
    Serial.print(" (Rod: ");
    Serial.print(digitalRead(FLAME_ROD_OUT_PIN) ? "ON" : "OFF");
    Serial.println(")");
    delay(1000);
  }
  while (Serial.available()) Serial.read(); // Clear buffer
  
  Serial.println("Taking flame readings...");
  int flameTotal = 0;
  for (int i = 0; i < 10; i++) {
    int reading = analogRead(FLAME_SENSE_PIN);
    flameTotal += reading;
    Serial.print("With flame ");
    Serial.print(i + 1);
    Serial.print(": ");
    Serial.println(reading);
    delay(300);
  }
  int flameAverage = flameTotal / 10;
  
  Serial.print("GOOD: Flame average: ");
  Serial.println(flameAverage);
  
  // Calculate results
  int difference = flameAverage - noFlameAverage;
  int recommendedThreshold = noFlameAverage + (difference / 3); // 33% above baseline
  
  Serial.println("\n--- CALIBRATION RESULTS ---");
  Serial.print("No flame: ");
  Serial.print(noFlameAverage);
  Serial.print(" | With flame: ");
  Serial.println(flameAverage);
  Serial.print("Difference: ");
  Serial.print(difference);
  Serial.print(" | Ratio: ");
  if (noFlameAverage > 0) {
    Serial.print((float)flameAverage / noFlameAverage, 1);
    Serial.println(":1");
  } else {
    Serial.println("N/A");
  }
  
  Serial.print("Current threshold: ");
  Serial.println(FLAME_DETECTION_THRESHOLD);
  Serial.print("Recommended threshold: ");
  Serial.println(recommendedThreshold);
  
  if (difference < 20) {
    Serial.println("\nPOOR: Very small flame signal");
    Serial.println("   Check: Flame rod in flame path, 1MΩ resistor, connections");
  } else if (difference < 50) {
    Serial.println("\nWARNING: MARGINAL: Weak flame signal");
    Serial.println("   Consider: Better flame rod position, AC voltage source");
  } else {
    Serial.println("\nGOOD: Strong flame rectification signal");
  }
  
  Serial.println("\n--- UPDATE FIRMWARE ---");
  Serial.println("To use new threshold, change this line:");
  Serial.print("const int FLAME_DETECTION_THRESHOLD = ");
  Serial.print(recommendedThreshold);
  Serial.println(";");
  Serial.println("============================");
  
  setFlameRodOutput(false); // Turn off flame rod after calibration
}

// --- Flame Rod Level Testing Function ---
void testFlameRodLevels() {
  Serial.println("\n=== FLAME ROD OUTPUT LEVEL TEST ===");
  Serial.println("Testing different flame rod output levels...");
  Serial.println("This simulates different flame intensities for sensor calibration");
  Serial.println("Format: Level | Output | ADC Reading | Detected | Notes");
  Serial.println("========================================================");
  
  // Test each level for 3 seconds with readings
  int levels[] = {0, 1, 2, 3, 4};
  String levelNames[] = {"OFF", "LOW", "MEDIUM", "HIGH", "FULL"};
  String voltages[] = {"0V", "~0.8V", "~1.6V", "~2.5V", "3.3V"};
  
  for (int i = 0; i < 5; i++) {
    Serial.print("\n--- Testing Level ");
    Serial.print(levels[i]);
    Serial.print(" (");
    Serial.print(levelNames[i]);
    Serial.print(" - ");
    Serial.print(voltages[i]);
    Serial.println(") ---");
    
    setFlameRodOutputLevel(levels[i]);
    delay(500); // Let output stabilize
    
    // Take 5 readings over 2.5 seconds
    int total = 0;
    int maxReading = 0;
    int minReading = 1024;
    int detectedCount = 0;
    
    for (int j = 0; j < 5; j++) {
      int reading = analogRead(FLAME_SENSE_PIN);
      bool detected = reading > FLAME_DETECTION_THRESHOLD;
      
      total += reading;
      if (reading > maxReading) maxReading = reading;
      if (reading < minReading) minReading = reading;
      if (detected) detectedCount++;
      
      Serial.print("  Reading ");
      Serial.print(j + 1);
      Serial.print(": ");
      Serial.print(reading);
      Serial.print(" | ");
      Serial.print(detected ? "FLAME" : "none ");
      
      if (j == 0) {
        // Add interpretation for first reading
        if (levels[i] == 0 && reading < 20) {
          Serial.print(" | GOOD: Good baseline");
        } else if (levels[i] > 0 && reading > FLAME_DETECTION_THRESHOLD) {
          Serial.print(" | GOOD: Good flame signal");
        } else if (levels[i] > 0 && reading <= FLAME_DETECTION_THRESHOLD) {
          Serial.print(" | WARNING: Weak signal");
        }
      }
      Serial.println();
      
      delay(500);
    }
    
    int average = total / 5;
    Serial.print("  Summary - Avg: ");
    Serial.print(average);
    Serial.print(" | Range: ");
    Serial.print(minReading);
    Serial.print("-");
    Serial.print(maxReading);
    Serial.print(" | Detection: ");
    Serial.print(detectedCount);
    Serial.println("/5");
    
    // Analysis
    if (levels[i] == 0) {
      if (average < 30) {
        Serial.println("  GOOD: Good baseline - low noise");
      } else {
        Serial.println("  WARNING: High baseline - check wiring");
      }
    } else {
      int signalIncrease = average - 20; // Assume ~20 baseline
      if (signalIncrease > 50) {
        Serial.println("  GOOD: Strong signal increase");
      } else if (signalIncrease > 20) {
        Serial.println("  INFO: Moderate signal increase");
      } else {
        Serial.println("  PROBLEM: Weak signal - check circuit");
      }
    }
  }
  
  Serial.println("\n=== TEST COMPLETE ===");
  Serial.println("Analysis:");
  Serial.println("- Level 0 should show low baseline readings");
  Serial.println("- Higher levels should show increasing ADC values");
  Serial.println("- Flame detection should trigger at higher levels");
  Serial.println("- If all levels show similar readings, check:");
  Serial.println("  * 1MΩ resistor connection");
  Serial.println("  * A0 pin wiring");
  Serial.println("  * GPIO5 output circuit");
  
  // Return to OFF state
  setFlameRodOutputLevel(0);
  Serial.println("\nFlame rod output returned to OFF");
  Serial.println("=============================");
}
