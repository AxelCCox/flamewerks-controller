<!--
To test this UI, open the following file in your browser:

file:///C:/Users/AxelC/OneDrive/Desktop/Flamewerks%20App/webui.html

Or, if hosted on your ESP8266, connect your device to the ESP Wi-Fi and visit:

http://192.168.4.1/webui.html

-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Burner Control Panel</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f5f5f5; }
    .container { max-width: 700px; margin: 0 auto; padding: 1em; }
    h1 { text-align: center; }
    .master-switch {
      display: flex; justify-content: center; align-items: center; margin: 1em 0;
    }
    .master-switch label {
      font-size: 1.2em; margin-right: 1em;
    }
    .switch {
      position: relative; display: inline-block; width: 60px; height: 34px;
    }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
      position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
      background-color: #ccc; transition: .4s; border-radius: 34px;
    }
    .slider:before {
      position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px;
      background-color: white; transition: .4s; border-radius: 50%;
    }
    input:checked + .slider { background-color: #4CAF50; }
    input:checked + .slider:before { transform: translateX(26px); }
    .burner-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr); /* Always 4 columns for up to 8 burners */
      gap: 1em;
      margin-top: 1.5em;
      justify-items: center;
    }
    .burner-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 90px;
      height: 90px;
      border-radius: 12px;
      color: #fff;
      font-weight: bold;
      font-size: 1.1em;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      user-select: none;
      cursor: pointer;
      border: 2px solid transparent;
      transition: border 0.2s, box-shadow 0.2s;
      margin: 0;
    }
    .burner-on-ok { background: #43a047; }
    .burner-on-flameout { background: #ff9800; }
    .burner-off { background: #b71c1c; }
    .burner-unknown { background: #888; }
    .burner-selected { border: 2px solid #1976d2; box-shadow: 0 0 0 2px #1976d2; }
    .burner-label { font-size: 0.9em; margin-top: 0.3em; }
    @media (max-width: 600px) {
      .container { padding: 0.2em; }
      .burner-box { font-size: 1em; height: 70px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Burner Control Panel</h1>
    <div class="master-switch">
      <label for="masterSwitch">Master Switch</label>
      <label class="switch">
        <input type="checkbox" id="masterSwitch" onchange="toggleMasterSwitch(this)">
        <span class="slider"></span>
      </label>
    </div>
    <div id="burnerGrid" class="burner-grid"></div>
    <div style="text-align:center; margin-top:1em;">
      <button onclick="sendCommand('reset')">Reset</button>
      <button onclick="sendCommand('off')">Emergency Stop</button>
    </div>
  </div>
  <script>
    // --- Configuration ---
    // Add your other burners here, each with a name and API base URL
    const BURNERS = [
      // Example: { name: "Burner 1", api: "http://192.168.4.2" },
      // Example: { name: "Burner 2", api: "http://192.168.4.3" },
      { name: "FlameWerks Burner", api: location.origin } // This project
    ];

    // Fetch status from firmware for a given burner
    async function fetchStatus(api) {
      try {
        const res = await fetch(`${api}/status`);
        if (!res.ok) throw new Error("Status fetch failed");
        return await res.json();
      } catch (e) {
        return { state: "UNKNOWN", flame: false };
      }
    }

    // Send control command to firmware for a given burner
    async function sendCommandToBurner(api, cmd) {
      try {
        await fetch(`${api}/control`, {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: `cmd=${encodeURIComponent(cmd)}`
        });
        setTimeout(updateGrid, 300); // Refresh after command
      } catch (e) {
        alert("Failed to send command.");
      }
    }

    // Master switch handler (controls all burners)
    function toggleMasterSwitch(el) {
      BURNERS.forEach(burner => sendCommandToBurner(burner.api, el.checked ? "on" : "off"));
    }

    // Send command to all burners (for reset/emergency stop)
    function sendCommand(cmd) {
      BURNERS.forEach(burner => sendCommandToBurner(burner.api, cmd));
    }

    // Render the burners grid
    async function updateGrid() {
      const grid = document.getElementById('burnerGrid');
      grid.innerHTML = '';
      let allOn = true;
      for (let i = 0; i < BURNERS.length; i++) {
        const burner = BURNERS[i];
        const status = await fetchStatus(burner.api);
        let boxClass = 'burner-box ';
        if (status.state === 'MAIN_ON' && status.flame) boxClass += 'burner-on-ok';
        else if (status.state === 'MAIN_ON' && !status.flame) boxClass += 'burner-on-flameout';
        else if (status.state === 'OFF') { boxClass += 'burner-off'; allOn = false; }
        else boxClass += 'burner-unknown';

        // Flame label logic
        let flameLabel = '';
        if (status.state === 'OFF') flameLabel = 'Flame Off';
        else if (status.state === 'MAIN_ON' && status.flame) flameLabel = 'Flame On';
        else if (status.state === 'MAIN_ON' && !status.flame) flameLabel = 'Flame Not Detected';
        else flameLabel = status.state;

        const div = document.createElement('div');
        div.className = boxClass;
        div.innerHTML = `
          <div>${burner.name}</div>
          <div>${status.state}</div>
          <div class="burner-label">${flameLabel}</div>
        `;
        div.onclick = () => sendCommandToBurner(burner.api, status.state === 'MAIN_ON' ? 'off' : 'on');
        grid.appendChild(div);
      }
      // Set master switch state
      document.getElementById('masterSwitch').checked = allOn;
    }

    // Auto-refresh every 2 seconds
    setInterval(updateGrid, 2000);
    updateGrid();
  </script>
</body>
</html>
        div.dataset.burnerId = burner.id;
        div.innerHTML = `
          <div>Burner ${burner.id}</div>
          <div>${burner.status.toUpperCase()}</div>
          <div class="burner-label">${flameLabel}</div>
        `;
        // Mouse/touch events for click-and-drag selection
        div.addEventListener('mousedown', e => startDrag(burner.id, burner.status));
        div.addEventListener('mouseenter', e => dragOver(burner.id));
        div.addEventListener('mouseup', endDrag);
        div.addEventListener('touchstart', e => { e.preventDefault(); startDrag(burner.id, burner.status); });
        div.addEventListener('touchmove', e => {
          const touch = e.touches[0];
          const elem = document.elementFromPoint(touch.clientX, touch.clientY);
          if (elem && elem.classList.contains('burner-box')) {
            dragOver(Number(elem.dataset.burnerId));
          }
        });
        div.addEventListener('touchend', endDrag);
        div.onclick = () => sendCommand(burner.id, burner.status === 'on' ? 'off' : 'on');
        grid.appendChild(div);
      });
      // Set master switch state
      document.getElementById('masterSwitch').checked = allOn;
    }

    // Drag selection logic
    function startDrag(burnerId, status) {
      isDragging = true;
      dragCommand = status === 'on' ? 'off' : 'on';
      selectedBurners.clear();
      selectedBurners.add(burnerId);
      updateGridHighlight();
      document.addEventListener('mouseup', endDrag);
      document.addEventListener('mousemove', mouseDragOver);
    }
    function dragOver(burnerId) {
      if (isDragging) {
        selectedBurners.add(burnerId);
        updateGridHighlight();
      }
    }
    function mouseDragOver(e) {
      const elem = document.elementFromPoint(e.clientX, e.clientY);
      if (elem && elem.classList.contains('burner-box')) {
        dragOver(Number(elem.dataset.burnerId));
      }
    }
    function endDrag() {
      if (isDragging && selectedBurners.size > 0) {
        sendCommand(Array.from(selectedBurners), dragCommand);
      }
      isDragging = false;
      dragCommand = null;
      selectedBurners.clear();
      updateGridHighlight();
      document.removeEventListener('mouseup', endDrag);
      document.removeEventListener('mousemove', mouseDragOver);
    }
    function updateGridHighlight() {
      document.querySelectorAll('.burner-box').forEach(box => {
        if (selectedBurners.has(Number(box.dataset.burnerId))) {
          box.classList.add('burner-selected');
        } else {
          box.classList.remove('burner-selected');
        }
      });
    }

    // Auto-refresh every 2 seconds
    setInterval(updateGrid, 2000);
    updateGrid();
  </script>
</body>
</html>
</body>
</html>
