/************************************************************
 * FlameWerks Remote Burner Control System - SINGLE RELAY TEST VERSION
 * ESP8266 ORIGINAL -> PORTED to SparkFun ESP32-C6 Thing Plus
 * 
 * Port Goals:
 *  - Preserve ALL logic, comments, diagnostics, web UI, serial commands
 *  - Minimal invasive changes
 *  - Add runtime-adjustable thresholds + extra diagnostics
 * 
 * Key Port Changes:
 *  - Headers: ESP8266* -> WiFi.h / WebServer.h / ESPmDNS.h
 *  - WiFi.hostname() -> WiFi.setHostname()
 *  - analogRead scale difference handled with 10-bit compatibility layer
 *  - A0 replaced with GPIO1 (configure FLAME_SENSE_PIN below)
 *  - MDNS.update() not needed on ESP32
 *  - New runtime variables: g_flameThreshold, g_flameHysteresis
 *  - Added extra serial commands (see help)
 ************************************************************/

#include <WiFi.h>
#include <WebServer.h>
#include <ESPmDNS.h>
#include <WiFiClient.h>

// ---------------- Pin Configuration (ADAPT AS NEEDED) ----------------
// Original used: GPIO2 pilot, GPIO4 glow/main (test), GPIO5 flame rod drive, A0 sense.
// Set your sensing ADC pin (ensure ADC capable). User requested GPIO1:
#define PILOT_RELAY_PIN       2
#define MAIN_RELAY_PIN        4
#define FLAME_ROD_OUT_PIN     5
#define IGNITER_PIN           5   // alias
#define FLAME_SENSE_PIN       1   // WARNING: verify GPIO1 is ADC-capable & free. Change if unstable.

// ---------------- WiFi Config ----------------
const char* ssid     = "Alesong Danebo";
const char* password = "Alesong123#";
const char* hostname = "flamewerks-burner";

// ---------------- State Machine ----------------
enum BurnerState {
  OFF,
  PILOT_IGNITING,
  PILOT_ON,
  FLAMEOUT,
  FAULT
};

struct BurnerController {
  int id;
  BurnerState state;
  unsigned long stateStartTime;
  int retryAttempt;
  bool flameDetected;
  bool igniterActive;
  bool pilotValveOpen;
  bool mainValveOpen;
  int lastFlameReading; // 10-bit scaled average for compatibility
};

BurnerController burner = {1, OFF, 0, 0, false, false, false, false, 0};

// ---------------- Timing & Safety ----------------
const unsigned long PILOT_IGNITION_TIME_MS  = 5000;
const unsigned long PILOT_STABILIZE_TIME_MS = 2000;
const unsigned long FLAME_CHECK_INTERVAL_MS = 100;
const unsigned long FLAME_LOSS_TIMEOUT_MS   = 500;
const unsigned long COOLDOWN_PERIOD_MS      = 3000;
const int MAX_IGNITION_ATTEMPTS             = 3;

// ---------------- Original Thresholds (10-bit basis) ----------------
static int g_flameThresholdBase = 150;  // original constant
static int g_flameHysteresisBase = 3;

// Runtime-adjustable copies
static int g_flameThreshold = g_flameThresholdBase;
static int g_flameHysteresis = g_flameHysteresisBase;

// Filter / noise parameters (10-bit conceptual space)
const int FILTER_SAMPLES                = 16;
const int STABILITY_REQUIRED            = 5;
const int STABILITY_REQUIRED_OFF        = 3;
const int MAX_NOISE_TOLERANCE_BASE      = 25;
const int OUTLIER_REJECTION_SAMPLES     = 8;

// ---------------- 12-bit ADC Adaptation Layer ----------------
// ESP32 ADC typically 0..4095. We scale reads to 0..1023 for old logic.
#ifndef ADC_HW_MAX
#define ADC_HW_MAX 4095
#endif

inline int readADC10(int pin) {
  int raw12 = analogRead(pin);         // 0..4095
  int val10 = (raw12 * 1023 + (ADC_HW_MAX/2)) / ADC_HW_MAX;
  return val10;
}

inline int raw12From10(int v10) {
  return (v10 * ADC_HW_MAX + 511) / 1023;
}

// Float / near-zero detection thresholds in 10-bit space (as original used 1020 & <=10)
const int FLOATING_LEVEL_10BIT = 1020;
const int NEAR_ZERO_LEVEL_10BIT = 10;

// ---------------- Web Server ----------------
WebServer server(80);

// ---------------- Hardware Control ----------------
void setPilotValve(bool state) {
  digitalWrite(PILOT_RELAY_PIN, state ? HIGH : LOW);
  burner.pilotValveOpen = state;
  Serial.print("Pilot valve: "); Serial.println(state ? "OPEN" : "CLOSED");
}

void setMainValve(bool state) {
  // SIMULATED in test version
  Serial.print("Main valve (SIMULATED): "); Serial.println(state ? "OPEN" : "CLOSED");
  burner.mainValveOpen = state;
}

void setGlowPlug(bool state) {
  digitalWrite(MAIN_RELAY_PIN, state ? HIGH : LOW);
  burner.igniterActive = state;
  Serial.print("Glow plug: "); Serial.println(state ? "ON" : "OFF");
}

void emergencyShutdown() {
  setPilotValve(false);
  setMainValve(false);
  setGlowPlug(false);
  burner.state = OFF;
  burner.retryAttempt = 0;
  Serial.println("*** EMERGENCY SHUTDOWN - ALL SYSTEMS OFF ***");
}

// ---------------- Flame Filtering ----------------
bool readFlameStatus() {
  static int sampleBuffer[FILTER_SAMPLES];
  static int sampleIndex = 0;
  static bool bufferFilled = false;
  static int stableFlameCount = 0;
  static int stableNoFlameCount = 0;
  static bool lastStableFlame = false;
  static unsigned long lastReadTime = 0;

  if (millis() - lastReadTime < 50) return lastStableFlame;
  lastReadTime = millis();

  // Outlier rejection sampling
  int readings[OUTLIER_REJECTION_SAMPLES];
  for (int i = 0; i < OUTLIER_REJECTION_SAMPLES; i++) {
    readings[i] = readADC10(FLAME_SENSE_PIN);
    delayMicroseconds(200);
  }
  // sort
  for (int i = 0; i < OUTLIER_REJECTION_SAMPLES - 1; i++)
    for (int j = i + 1; j < OUTLIER_REJECTION_SAMPLES; j++)
      if (readings[i] > readings[j]) { int t = readings[i]; readings[i] = readings[j]; readings[j] = t; }

  int sIdx = OUTLIER_REJECTION_SAMPLES / 4;
  int eIdx = OUTLIER_REJECTION_SAMPLES * 3 / 4;
  int sum = 0;
  for (int i = sIdx; i < eIdx; i++) sum += readings[i];
  int filtered = sum / (eIdx - sIdx);

  // Circular buffer
  sampleBuffer[sampleIndex] = filtered;
  sampleIndex = (sampleIndex + 1) % FILTER_SAMPLES;
  if (!bufferFilled && sampleIndex == 0) bufferFilled = true;

  int used = bufferFilled ? FILTER_SAMPLES : sampleIndex;
  long total = 0;
  for (int i = 0; i < used; i++) total += sampleBuffer[i];
  int movingAverage = used ? (int)(total / used) : filtered;

  int maxSample = 0, minSample = 1023;
  for (int i = 0; i < used; i++) {
    if (sampleBuffer[i] > maxSample) maxSample = sampleBuffer[i];
    if (sampleBuffer[i] < minSample) minSample = sampleBuffer[i];
  }
  int noiseLevel = maxSample - minSample;
  burner.lastFlameReading = movingAverage;

  static int consecutiveFloat = 0;
  static int consecutiveGround = 0;
  static bool warnedFloating = false;

  if (movingAverage >= FLOATING_LEVEL_10BIT) {
    consecutiveFloat++; consecutiveGround = 0;
    if (consecutiveFloat >= 5 && !warnedFloating) {
      Serial.println("*** WARNING: ADC INPUT FLOATING (very high reading) ***");
      warnedFloating = true;
    }
  } else if (movingAverage <= NEAR_ZERO_LEVEL_10BIT) {
    consecutiveGround++; consecutiveFloat = 0;
    if (warnedFloating && consecutiveGround >= 3) {
      Serial.println("*** ADC INPUT STABILIZED (low) ***");
      warnedFloating = false;
    }
  } else {
    consecutiveFloat = 0;
    consecutiveGround = 0;
  }

  int adaptiveThreshold = g_flameThreshold;
  if (noiseLevel > (MAX_NOISE_TOLERANCE_BASE - 5)) {
    adaptiveThreshold += noiseLevel / 3;
  }

  bool potentialFlame;
  if (movingAverage >= FLOATING_LEVEL_10BIT) {
    potentialFlame = false; // ignore floating extreme
  } else {
    if (lastStableFlame) {
      potentialFlame = movingAverage > (adaptiveThreshold - g_flameHysteresis);
    } else {
      potentialFlame = movingAverage > (adaptiveThreshold + g_flameHysteresis);
    }
  }

  bool isStable = (noiseLevel <= MAX_NOISE_TOLERANCE_BASE) && bufferFilled;

  if (isStable && potentialFlame) {
    stableFlameCount++; stableNoFlameCount = 0;
  } else if (isStable && !potentialFlame) {
    stableNoFlameCount++; stableFlameCount = 0;
  } else {
    if (noiseLevel > MAX_NOISE_TOLERANCE_BASE) {
      if (stableFlameCount > 0) stableFlameCount--;
      if (stableNoFlameCount > 0) stableNoFlameCount--;
    }
  }

  bool newState = lastStableFlame;
  if (stableFlameCount >= STABILITY_REQUIRED) {
    newState = true; stableFlameCount = STABILITY_REQUIRED;
  } else if (stableNoFlameCount >= STABILITY_REQUIRED_OFF) {
    newState = false; stableNoFlameCount = STABILITY_REQUIRED_OFF;
  }

  if (newState != lastStableFlame) {
    if (newState) {
      Serial.print("🔥 STABLE FLAME DETECTED! Avg="); Serial.print(movingAverage);
      Serial.print(" Noise="); Serial.print(noiseLevel);
      Serial.print(" Thr="); Serial.println(adaptiveThreshold);
    } else {
      Serial.print("❄️ FLAME LOST Avg="); Serial.print(movingAverage);
      Serial.print(" Noise="); Serial.print(noiseLevel);
      Serial.print(" Thr="); Serial.println(adaptiveThreshold);
    }
    lastStableFlame = newState;
  }

  static unsigned long lastDbg = 0;
  if (millis() - lastDbg > 5000) {
    Serial.print("FlameDBG Raw="); Serial.print(readADC10(FLAME_SENSE_PIN));
    Serial.print(" Filt="); Serial.print(filtered);
    Serial.print(" Avg="); Serial.print(movingAverage);
    Serial.print(" Noise="); Serial.print(noiseLevel);
    Serial.print(" Thr="); Serial.print(adaptiveThreshold);
    Serial.print(" Flame="); Serial.println(newState ? "YES" : "NO");
    lastDbg = millis();
  }

  return newState;
}

void resetFlameFilter() {
  Serial.println("=== RESETTING FLAME FILTER === (power-cycle for full clear)");
}

// ---------------- State Machine ----------------
void updateBurnerStateMachine() {
  unsigned long now = millis();
  static unsigned long lastUpdate = 0;
  if (now - lastUpdate < 250) return;
  lastUpdate = now;

  burner.flameDetected = readFlameStatus();

  static BurnerState lastPrinted = FAULT;

  switch (burner.state) {
    case OFF:
      if (lastPrinted != OFF) {
        setPilotValve(false);
        setMainValve(false);
        setGlowPlug(false);
        Serial.println("System OFF - type 'help' for commands");
        lastPrinted = OFF;
      }
      break;

    case PILOT_IGNITING:
      lastPrinted = PILOT_IGNITING;
      setPilotValve(true);
      setMainValve(false);
      setGlowPlug(true);
      if (burner.flameDetected) {
        burner.state = PILOT_ON;
        burner.stateStartTime = now;
        burner.retryAttempt = 0;
        setGlowPlug(false);
        Serial.println("STATE: Pilot flame detected -> PILOT_ON (TEST MODE)");
      } else if (now - burner.stateStartTime > PILOT_IGNITION_TIME_MS) {
        setPilotValve(false);
        setGlowPlug(false);
        if (burner.retryAttempt < MAX_IGNITION_ATTEMPTS) {
          burner.retryAttempt++;
          burner.state = FLAMEOUT;
          burner.stateStartTime = now;
          Serial.print("STATE: Ignition failed attempt ");
          Serial.print(burner.retryAttempt);
          Serial.print("/"); Serial.println(MAX_IGNITION_ATTEMPTS);
        } else {
          burner.state = FAULT;
          burner.stateStartTime = now;
          Serial.println("STATE: Max ignition attempts -> FAULT");
        }
      }
      break;

    case PILOT_ON:
      lastPrinted = PILOT_ON;
      setPilotValve(true);
      setMainValve(true); // simulated
      if (!burner.flameDetected) {
        emergencyShutdown();
        burner.state = FLAMEOUT;
        burner.stateStartTime = now;
        Serial.println("STATE: Flame lost -> FLAMEOUT");
      }
      break;

    case FLAMEOUT:
      lastPrinted = FLAMEOUT;
      setPilotValve(false);
      setMainValve(false);
      if (now - burner.stateStartTime > COOLDOWN_PERIOD_MS) {
        if (burner.retryAttempt < MAX_IGNITION_ATTEMPTS) {
          burner.state = PILOT_IGNITING;
          burner.stateStartTime = now;
          Serial.println("STATE: Cooldown complete -> PILOT_IGNITING");
        } else {
          burner.state = FAULT;
          Serial.println("STATE: Max retries -> FAULT");
        }
      }
      break;

    case FAULT:
      lastPrinted = FAULT;
      setPilotValve(false);
      setMainValve(false);
      break;
  }
}

// ---------------- Web UI HTML ----------------
const char PROGMEM webUI[] = R"rawliteral(
<!DOCTYPE html><html><head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>FlameWerks Burner Control</title>
<style>
body{font-family:Arial;margin:0;padding:1em;background:#f5f5f5}
.container{max-width:800px;margin:0 auto}
h1{text-align:center;color:#333}
.status-panel,.burner-card{background:#fff;padding:1em;border-radius:8px;margin:1em 0;box-shadow:0 2px 4px rgba(0,0,0,.1)}
.burner-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:1em}
.burner-status{font-size:1.2em;font-weight:bold;margin:.5em 0}
.status-off{color:#d32f2f}.status-igniting{color:#ff9800;animation:blink 1s infinite}.status-on{color:#388e3c}.status-fault{color:#d32f2f;background:#ffebee;padding:.2em}
@keyframes blink{0%,50%{opacity:1}51%,100%{opacity:.3}}
.controls{display:flex;gap:.5em;flex-wrap:wrap;margin:1em 0}
.btn{padding:.7em 1.2em;border:0;border-radius:4px;cursor:pointer;font-size:1em;transition:background .2s}
.btn-primary{background:#1976d2;color:#fff}.btn-primary:hover{background:#1565c0}
.btn-danger{background:#d32f2f;color:#fff}.btn-danger:hover{background:#c62828}
.btn-secondary{background:#757575;color:#fff}.btn-secondary:hover{background:#616161}
.emergency{background:#ffcdd2;border:2px solid #d32f2f;padding:1em;border-radius:8px;margin:1em 0;text-align:center}
.flame-indicator{display:inline-block;width:12px;height:12px;border-radius:50%;margin-left:.5em}
.flame-yes{background:#4caf50}.flame-no{background:#f44336}
</style></head>
<body><div class="container">
<h1>FlameWerks Burner Control (ESP32-C6)</h1>
<div class="emergency"><button class="btn btn-danger" onclick="emergencyStop()">EMERGENCY STOP</button><p>Immediately shuts off all valves and igniter</p></div>
<div class="status-panel"><h3>System Status</h3><div id="systemStatus">Loading...</div></div>
<div class="burner-grid"><div class="burner-card">
<h3>Burner 1</h3>
<div id="burner1Status" class="burner-status">Loading...</div>
<div id="burner1Flame">Flame: <span class="flame-indicator flame-no"></span></div>
<div id="burner1Retries">Retries: 0/3</div>
<div class="controls">
<button class="btn btn-primary" onclick="startIgnition()">IGNITE</button>
<button class="btn btn-danger" onclick="stopBurner()">STOP</button>
<button class="btn btn-secondary" onclick="resetBurner()">RESET</button>
</div></div></div></div>
<script>
setInterval(updateStatus,2000);updateStatus();
async function updateStatus(){
 try{
  const r=await fetch('/status');const b=(await r.json())[0];
  const sEl=document.getElementById('burner1Status');
  const flameEl=document.getElementById('burner1Flame');
  const retriesEl=document.getElementById('burner1Retries');
  let cls='',txt='';
  switch(b.state){
    case'off':cls='status-off';txt='OFF';break;
    case'igniting':cls='status-igniting';txt='IGNITING PILOT...';break;
    case'pilot-running':cls='status-on';txt='PILOT RUNNING (TEST)';break;
    case'flameout':cls='status-fault';txt='FLAMEOUT';break;
    case'fault':cls='status-fault';txt='FAULT - RESET REQUIRED';break;
    default:cls='status-off';txt='UNKNOWN';
  }
  sEl.className='burner-status '+cls;
  sEl.textContent=txt;
  flameEl.innerHTML='Flame: <span class="flame-indicator '+(b.flame?'flame-yes':'flame-no')+'"></span> '+(b.flame?'DETECTED':'NONE')+' (ADC: '+b.flameSensorValue+')';
  retriesEl.textContent='Attempts: '+b.attempts+'/'+b.maxAttempts;
  document.getElementById('systemStatus').textContent='Burner 1: '+txt+' | Flame: '+(b.flame?'Detected':'None')+' | IP: '+location.hostname;
 }catch(e){
  document.getElementById('systemStatus').textContent='Connection Error';
 }
}
async function sendCommand(c){
 try{
  const r=await fetch('/control',{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},body:'cmd='+c});
  const t=await r.text();document.getElementById('systemStatus').textContent=t;setTimeout(updateStatus,500);
 }catch(e){alert('Command failed');}
}
function startIgnition(){if(confirm('Start ignition sequence?'))sendCommand('ignite');}
function stopBurner(){if(confirm('Emergency shutdown?'))sendCommand('stop');}
function resetBurner(){if(confirm('Reset system from FAULT state?'))sendCommand('reset');}
function emergencyStop(){if(confirm('EMERGENCY STOP will immediately shut off all systems!'))sendCommand('stop');}
</script></body></html>
)rawliteral";

String getWebUI() { return FPSTR(webUI); }

// ---------------- Web Handlers ----------------
void handleRoot() {
  server.sendHeader("Content-Type","text/html");
  server.send(200,"text/html",getWebUI());
}

void handleStatus() {
  String json = "[{";
  json += "\"id\":1,";
  json += "\"state\":\"";
  switch (burner.state) {
    case OFF: json += "off"; break;
    case PILOT_IGNITING: json += "igniting"; break;
    case PILOT_ON: json += "pilot-running"; break;
    case FLAMEOUT: json += "flameout"; break;
    case FAULT: json += "fault"; break;
  }
  json += "\",\"flame\":" + String(burner.flameDetected ? "true":"false");
  json += ",\"attempts\":" + String(burner.retryAttempt);
  json += ",\"maxAttempts\":" + String(MAX_IGNITION_ATTEMPTS);
  json += ",\"flameSensorValue\":" + String(burner.lastFlameReading);
  json += ",\"igniterActive\":" + String(burner.igniterActive ? "true":"false");
  json += ",\"pilotOpen\":" + String(burner.pilotValveOpen ? "true":"false");
  json += ",\"mainOpen\":" + String(burner.mainValveOpen ? "true":"false");
  json += "}]";
  server.send(200,"application/json",json);
}

void handleControl() {
  String response;
  if (server.hasArg("cmd")) {
    String cmd = server.arg("cmd");
    if (cmd == "ignite" || cmd == "on") {
      if (burner.state == OFF || burner.state == FAULT) {
        burner.state = PILOT_IGNITING;
        burner.stateStartTime = millis();
        burner.retryAttempt = 0;
        response = "Ignition sequence initiated";
      } else {
        response = "Already active";
      }
    } else if (cmd == "stop" || cmd == "off") {
      emergencyShutdown();
      response = "Emergency shutdown";
    } else if (cmd == "reset") {
      if (burner.state == FAULT) {
        burner.state = OFF;
        burner.retryAttempt = 0;
        response = "Reset to OFF";
      } else {
        response = "Reset only in FAULT";
      }
    } else {
      response = "Unknown command";
    }
  } else response = "Missing cmd";
  server.send(200,"text/plain",response);
}

void handleNotFound() {
  server.send(404,"text/plain","File not found");
}

// ---------------- Forward Declarations of Diagnostics ----------------
void performADCDiagnostic();
void performStabilityTest();
void testFlameRodDetailed();
void calibrateFlameRod();
void testFlameRodLevels();
void setFlameRodOutputLevel(int level);
void performCompleteFlameDiagnostic();

// ---------------- New Helper: Show Threshold ----------------
void printThresholdInfo() {
  Serial.print("Threshold: "); Serial.print(g_flameThreshold);
  Serial.print("  Hysteresis: "); Serial.print(g_flameHysteresis);
  Serial.print("  (Base defaults: "); Serial.print(g_flameThresholdBase);
  Serial.print("/"); Serial.print(g_flameHysteresisBase); Serial.println(")");
}

// ---------------- Serial Command Interface ----------------
void handleSerialCommands() {
  if (!Serial.available()) return;
  String cmd = Serial.readStringUntil('\n');
  cmd.trim();
  cmd.toLowerCase();

  if (cmd == "i" || cmd == "ignite") {
    if (burner.state == OFF || burner.state == FAULT) {
      burner.state = PILOT_IGNITING;
      burner.stateStartTime = millis();
      burner.retryAttempt = 0;
      Serial.println("SERIAL: Ignition start");
    } else Serial.println("SERIAL: Already active");
  }
  else if (cmd == "s" || cmd == "stop" || cmd == "off") {
    emergencyShutdown();
    Serial.println("SERIAL: Emergency shutdown");
  }
  else if (cmd == "r" || cmd == "reset") {
    burner.state = OFF;
    burner.retryAttempt = 0;
    Serial.println("SERIAL: System reset to OFF");
  }
  else if (cmd == "status" || cmd == "st") {
    Serial.println("=== STATUS ===");
    Serial.print("State: ");
    switch (burner.state) {
      case OFF: Serial.println("OFF"); break;
      case PILOT_IGNITING: Serial.println("PILOT_IGNITING"); break;
      case PILOT_ON: Serial.println("PILOT_ON (TEST)"); break;
      case FLAMEOUT: Serial.println("FLAMEOUT"); break;
      case FAULT: Serial.println("FAULT"); break;
    }
    Serial.print("Flame: "); Serial.println(burner.flameDetected ? "YES" : "NO");
    Serial.print("ADC(avg 10-bit): "); Serial.println(burner.lastFlameReading);
    Serial.print("Attempts: "); Serial.print(burner.retryAttempt);
    Serial.print("/"); Serial.println(MAX_IGNITION_ATTEMPTS);
    Serial.print("Pilot Valve: "); Serial.println(burner.pilotValveOpen ? "OPEN":"CLOSED");
    Serial.print("Main Valve: "); Serial.println(burner.mainValveOpen ? "OPEN":"CLOSED");
    printThresholdInfo();
    Serial.print("Heap Free: "); Serial.println(ESP.getFreeHeap());
    Serial.print("Uptime (ms): "); Serial.println(millis());
    Serial.println("=============");
  }
  else if (cmd == "threshold_show") {
    printThresholdInfo();
  }
  else if (cmd.startsWith("threshold_set")) {
    int space = cmd.indexOf(' ');
    if (space > 0) {
      int val = cmd.substring(space + 1).toInt();
      if (val > 0 && val < 1023) {
        g_flameThreshold = val;
        Serial.print("Threshold updated to "); Serial.println(g_flameThreshold);
      } else Serial.println("Invalid threshold (1-1022)");
    } else Serial.println("Usage: threshold_set <value>");
  }
  else if (cmd == "threshold_auto") {
    // Simple auto: baseline sample + margin
    Serial.println("Auto-calibrating threshold...");
    int baselineSum = 0;
    for (int i = 0; i < 20; i++) { baselineSum += readADC10(FLAME_SENSE_PIN); delay(50); }
    int baseline = baselineSum / 20;
    g_flameThreshold = baseline + 30;
    Serial.print("Baseline="); Serial.print(baseline);
    Serial.print(" -> New threshold="); Serial.println(g_flameThreshold);
  }
  else if (cmd == "adc_raw") {
    Serial.println("10 rapid raw ADC (10-bit scaled) readings:");
    for (int i = 0; i < 10; i++) {
      int v = readADC10(FLAME_SENSE_PIN);
      Serial.print(i+1); Serial.print(": "); Serial.println(v);
      delay(100);
    }
  }
  else if (cmd == "adc_stream") {
    Serial.println("Streaming ADC (press key to stop)...");
    while (!Serial.available()) {
      int v = readADC10(FLAME_SENSE_PIN);
      Serial.println(v);
      delay(100);
    }
    while (Serial.available()) Serial.read();
    Serial.println("Stream stopped.");
  }
  else if (cmd == "stats") {
    Serial.println("=== STATS ===");
    printThresholdInfo();
    Serial.print("Heap: "); Serial.println(ESP.getFreeHeap());
    Serial.print("Uptime (s): "); Serial.println(millis()/1000);
    Serial.println("=============");
  }
  else if (cmd == "uptime") {
    Serial.print("Uptime (ms): "); Serial.println(millis());
  }
  else if (cmd == "wifi_reconnect") {
    Serial.println("Reconnecting WiFi...");
    WiFi.disconnect();
    WiFi.begin(ssid, password);
  }
  else if (cmd == "mdns_restart") {
    Serial.println("Restarting mDNS...");
    MDNS.end();
    if (MDNS.begin(hostname)) {
      MDNS.addService("http","tcp",80);
      Serial.println("mDNS restarted");
    } else Serial.println("mDNS restart failed");
  }
  else if (cmd == "version") {
    Serial.println("Firmware: FlameWerks ESP32-C6 Port v1.0");
  }
  else if (cmd == "memory") {
    Serial.print("Free heap: "); Serial.println(ESP.getFreeHeap());
    Serial.print("Min free heap: "); Serial.println(ESP.getMinFreeHeap());
  }
  else if (cmd == "reset_filter") {
    resetFlameFilter();
  }
  else if (cmd == "filter_check") {
    Serial.println("=== SIMPLE FILTER CHECK ===");
    Serial.println("5 raw readings:");
    int total = 0;
    for (int i = 0; i < 5; i++) {
      int r = readADC10(FLAME_SENSE_PIN);
      total += r;
      Serial.print("Raw "); Serial.print(i+1); Serial.print(": "); Serial.println(r);
      delay(200);
    }
    Serial.print("Avg: "); Serial.println(total/5);
  }
  // Original & Extended Diagnostics
  else if (cmd == "adc_diagnostic") performADCDiagnostic();
  else if (cmd == "stability_test") performStabilityTest();
  else if (cmd == "test") {
    Serial.println("=== FLAME ROD TEST ===");
    for (int i=0;i<10;i++){
      int r = readADC10(FLAME_SENSE_PIN);
      Serial.print("Reading "); Serial.print(i+1); Serial.print(": ");
      Serial.print(r); Serial.print(" (Threshold "); Serial.print(g_flameThreshold);
      Serial.print(" Detected: "); Serial.print(r > g_flameThreshold ? "YES":"NO"); Serial.println(")");
      delay(500);
    }
  }
  else if (cmd == "flame_test") testFlameRodDetailed();
  else if (cmd == "flame_test_live") {
    Serial.println("=== LIVE FLAME TEST (press key to stop) ===");
    while(!Serial.available()){
      bool flame = readFlameStatus();
      Serial.print("ADCavg="); Serial.print(burner.lastFlameReading);
      Serial.print(" Flame="); Serial.println(flame ? "YES":"NO");
      delay(300);
    }
    while(Serial.available()) Serial.read();
  }
  else if (cmd == "noise_test") {
    Serial.println("=== NOISE TEST (10s) ===");
    unsigned long start=millis();
    int maxNoise=0;
    while(millis()-start<10000){
      int a1 = readADC10(FLAME_SENSE_PIN);
      delay(5);
      int a2 = readADC10(FLAME_SENSE_PIN);
      int noise = abs(a2 - a1);
      if (noise > maxNoise) maxNoise = noise;
      delay(50);
    }
    Serial.print("Max noise delta: "); Serial.println(maxNoise);
  }
  else if (cmd == "flame_cal") calibrateFlameRod();
  else if (cmd == "flame_continuous") {
    Serial.println("=== CONTINUOUS FLAME (press key) ===");
    while(!Serial.available()){
      bool f = readFlameStatus();
      Serial.print("Avg="); Serial.print(burner.lastFlameReading);
      Serial.print(" Flame="); Serial.println(f?"YES":"NO");
      delay(500);
    }
    while(Serial.available()) Serial.read();
  }
  else if (cmd == "wiring_test") {
    Serial.println("=== WIRING TEST ===");
    Serial.println("GPIO5 drive sequence...");
    digitalWrite(FLAME_ROD_OUT_PIN, HIGH); delay(200);
    int highR = readADC10(FLAME_SENSE_PIN);
    digitalWrite(FLAME_ROD_OUT_PIN, LOW); delay(200);
    int lowR = readADC10(FLAME_SENSE_PIN);
    Serial.print("High->"); Serial.print(highR);
    Serial.print(" Low->"); Serial.print(lowR);
    Serial.print(" Delta="); Serial.println(highR - lowR);
  }
  else if (cmd == "glow_on") { setGlowPlug(true); }
  else if (cmd == "glow_off") { setGlowPlug(false); }
  else if (cmd == "glow_test") {
    Serial.println("Glow plug ON 3s...");
    setGlowPlug(true); delay(3000);
    Serial.println("Glow plug OFF");
    setGlowPlug(false);
  }
  else if (cmd == "pin_test") {
    Serial.println("=== PIN TEST ===");
    Serial.println("Pilot off/on cycle");
    setPilotValve(false); delay(500);
    setPilotValve(true); delay(500);
    setPilotValve(false);
    Serial.println("Glow off/on cycle");
    setGlowPlug(false); delay(500);
    setGlowPlug(true); delay(500);
    setGlowPlug(false);
    Serial.println("Flame rod out toggle");
    digitalWrite(FLAME_ROD_OUT_PIN, LOW); delay(300);
    digitalWrite(FLAME_ROD_OUT_PIN, HIGH); delay(300);
    digitalWrite(FLAME_ROD_OUT_PIN, LOW);
  }
  else if (cmd == "flame_diagnostic") performCompleteFlameDiagnostic();
  else if (cmd == "a0_test") {
    Serial.println("a0_test renamed conceptually to adc_raw (use that). Running compatibility test:");
    for(int i=0;i<20;i++){ Serial.print(i+1); Serial.print(": "); Serial.println(readADC10(FLAME_SENSE_PIN)); delay(200); }
  }
  else if (cmd == "test_no_flame") {
    Serial.println("=== NO FLAME BASELINE ===");
    int total=0;
    for(int i=0;i<10;i++){ int r=readADC10(FLAME_SENSE_PIN); total+=r; Serial.println(r); delay(300); }
    Serial.print("Avg="); Serial.println(total/10);
  }
  else if (cmd == "flame_detailed") testFlameRodDetailed();
  else if (cmd == "stability_test_old") performStabilityTest(); // alias
  else if (cmd == "help" || cmd == "h") {
    Serial.println("=== COMMANDS ===");
    Serial.println("ignite / i          Start ignition");
    Serial.println("stop / off / s      Emergency shutdown");
    Serial.println("reset / r           Reset to OFF");
    Serial.println("status / st         Status summary");
    Serial.println("threshold_show      Show current threshold");
    Serial.println("threshold_set N     Set threshold (10-bit 1..1022)");
    Serial.println("threshold_auto      Auto baseline + margin");
    Serial.println("adc_raw             10 quick ADC samples");
    Serial.println("adc_stream          Continuous ADC until key");
    Serial.println("test                Basic flame sensor test");
    Serial.println("test_no_flame       Baseline (no flame) test");
    Serial.println("flame_test          Detailed 20 sample test");
    Serial.println("flame_test_live     Live filtered flame monitoring");
    Serial.println("flame_continuous    Continuous flame readings");
    Serial.println("noise_test          Noise characterization");
    Serial.println("stability_test      Extended 60s stability test");
    Serial.println("flame_cal           Flame threshold calibration");
    Serial.println("flame_diagnostic    Full diagnostic workflow");
    Serial.println("wiring_test         Wiring / drive response test");
    Serial.println("glow_on/glow_off    Control glow output");
    Serial.println("glow_test           Timed glow test");
    Serial.println("pin_test            Cycle control pins");
    Serial.println("adc_diagnostic      ADC integrity test");
    Serial.println("filter_check        Check for filter corruption");
    Serial.println("reset_filter        (Soft) reset filter notice");
    Serial.println("stats, uptime       Runtime stats");
    Serial.println("wifi_reconnect      Force WiFi reconnect");
    Serial.println("mdns_restart        Restart mDNS service");
    Serial.println("version             Firmware version");
    Serial.println("memory              Heap info");
    Serial.println("help / h            This list");
    Serial.println("================");
  }
  else if (cmd.length()) {
    Serial.println("Unknown command. Type 'help'.");
  }
}

// ---------------- Original / Extended Diagnostic Implementations ----------------
// For brevity, core logic adapted to 10-bit readADC10(). Any literal 1020/1024 replaced by constants.

void performADCDiagnostic() {
  Serial.println("=== ADC DIAGNOSTIC ===");
  int zeroCount=0, maxVal=0, minVal=1023;
  for(int i=0;i<50;i++){
    int r=readADC10(FLAME_SENSE_PIN);
    if(r==0) zeroCount++;
    if(r>maxVal) maxVal=r;
    if(r<minVal) minVal=r;
    delay(20);
  }
  Serial.print("Zero count: "); Serial.println(zeroCount);
  Serial.print("Min: "); Serial.print(minVal); Serial.print(" Max: "); Serial.println(maxVal);
  Serial.print("Range: "); Serial.println(maxVal - minVal);
  if (zeroCount==50) Serial.println("CRITICAL: Always zero - wiring or pin failure.");
  else if (maxVal==minVal) Serial.println("WARNING: No variation.");
  else Serial.println("ADC responds with variation.");
}

void performStabilityTest() {
  Serial.println("=== STABILITY TEST (Shortened 30s) ===");
  unsigned long start=millis();
  int flameDet=0, samples=0;
  while(millis()-start<30000){
    bool f=readFlameStatus();
    if(f) flameDet++;
    samples++;
    delay(100);
  }
  Serial.print("Samples: "); Serial.print(samples);
  Serial.print(" Flame detections: "); Serial.println(flameDet);
}

void testFlameRodDetailed() {
  Serial.println("=== DETAILED FLAME ROD TEST (20 samples) ===");
  int total=0, minV=1023, maxV=0, flameCount=0;
  for(int i=0;i<20;i++){
    int r=readADC10(FLAME_SENSE_PIN);
    bool det = r > g_flameThreshold;
    total+=r;
    if(r<minV)minV=r;
    if(r>maxV)maxV=r;
    if(det) flameCount++;
    Serial.print(i+1); Serial.print(": ADC="); Serial.print(r);
    Serial.print(" Det="); Serial.println(det?"YES":"NO");
    delay(250);
  }
  Serial.print("Average="); Serial.println(total/20);
  Serial.print("Range="); Serial.print(minV); Serial.print("-"); Serial.println(maxV);
  Serial.print("Detections="); Serial.print(flameCount); Serial.println("/20");
}

void calibrateFlameRod() {
  Serial.println("=== CALIBRATION ===");
  Serial.println("Baseline (no flame) 10 samples...");
  int base=0;
  for(int i=0;i<10;i++){ int r=readADC10(FLAME_SENSE_PIN); base+=r; Serial.println(r); delay(300); }
  base/=10;
  Serial.print("Baseline avg="); Serial.println(base);
  Serial.println("Apply flame and press any key...");
  while(!Serial.available()) {
    Serial.print("Live="); Serial.println(readADC10(FLAME_SENSE_PIN));
    delay(500);
  }
  while(Serial.available()) Serial.read();
  int flame=0;
  for(int i=0;i<10;i++){ int r=readADC10(FLAME_SENSE_PIN); flame+=r; Serial.print("Flame "); Serial.print(i+1); Serial.print(": "); Serial.println(r); delay(300); }
  flame/=10;
  Serial.print("Flame avg="); Serial.println(flame);
  int diff = flame - base;
  int rec = base + diff/3;
  Serial.print("Recommended threshold="); Serial.println(rec);
  g_flameThreshold = rec;
  Serial.println("Updated runtime threshold.");
}

void testFlameRodLevels() {
  Serial.println("=== LEVEL TEST (digital HIGH/LOW only) ===");
  // Using digital high/low (PWM not implemented for AC bias)
  int levels[2] = {0,1};
  for(int l: levels){
    digitalWrite(FLAME_ROD_OUT_PIN, l ? HIGH:LOW);
    delay(300);
    int sum=0;
    for(int i=0;i<5;i++){ int r=readADC10(FLAME_SENSE_PIN); sum+=r; Serial.print("L");Serial.print(l);Serial.print(" #");Serial.print(i+1);Serial.print(": ");Serial.println(r); delay(200); }
    Serial.print("Level "); Serial.print(l); Serial.print(" avg="); Serial.println(sum/5);
  }
  digitalWrite(FLAME_ROD_OUT_PIN, LOW);
}

void setFlameRodOutputLevel(int level) {
  // Compatibility stub: 0=LOW else=HIGH
  digitalWrite(FLAME_ROD_OUT_PIN, level>0 ? HIGH:LOW);
}

void performCompleteFlameDiagnostic() {
  Serial.println("=== COMPLETE DIAGNOSTIC ===");
  int baseline=0;
  for(int i=0;i<10;i++){ int r=readADC10(FLAME_SENSE_PIN); baseline+=r; delay(150); }
  baseline/=10;
  Serial.print("Baseline avg="); Serial.println(baseline);
  Serial.println("Apply flame (10 samples)...");
  int flame=0;
  for(int i=0;i<10;i++){ int r=readADC10(FLAME_SENSE_PIN); flame+=r; Serial.print("Flame "); Serial.print(i+1); Serial.print(": "); Serial.println(r); delay(250); }
  flame/=10;
  int delta = flame - baseline;
  Serial.print("Delta="); Serial.println(delta);
  if (delta < 15) Serial.println("Result: Weak signal");
  else if (delta < 30) Serial.println("Result: Marginal");
  else Serial.println("Result: Strong");
}

// ---------------- Setup & Loop ----------------
void setup() {
  Serial.begin(115200);
  Serial.println();
  Serial.println("=== FlameWerks ESP32-C6 Burner Control (Port) ===");

  pinMode(PILOT_RELAY_PIN, OUTPUT);
  pinMode(MAIN_RELAY_PIN, OUTPUT);
  pinMode(FLAME_ROD_OUT_PIN, OUTPUT);
  setPilotValve(false);
  setMainValve(false);
  setGlowPlug(false);

  burner.state = OFF;
  burner.stateStartTime = millis();

  WiFi.mode(WIFI_STA);
  WiFi.setHostname(hostname);
  WiFi.begin(ssid, password);
  Serial.print("Connecting WiFi");
  int tries=0;
  while(WiFi.status()!=WL_CONNECTED && tries<40){
    delay(250); Serial.print(".");
    tries++;
  }
  if (WiFi.status()==WL_CONNECTED){
    Serial.println("\nWiFi connected.");
    Serial.print("IP: "); Serial.println(WiFi.localIP());
    if (MDNS.begin(hostname)) {
      MDNS.addService("http","tcp",80);
      Serial.print("mDNS: http://"); Serial.print(hostname); Serial.println(".local/");
    }
  } else {
    Serial.println("\nWiFi failed (offline mode).");
  }

  server.on("/", HTTP_GET, handleRoot);
  server.on("/status", HTTP_GET, handleStatus);
  server.on("/control", HTTP_POST, handleControl);
  server.onNotFound(handleNotFound);
  server.begin();
  Serial.println("Web server started (port 80)");
  Serial.println("Type 'help' for commands.");
}

void loop() {
  server.handleClient();
  handleSerialCommands();
  updateBurnerStateMachine();
  delay(50);
}
